require 'treetop'

module DNS
	# Autogenerated from a Treetop grammar. Edits may be lost.
	
	
	module ZonefileGrammar # :nodoc:
	  include Treetop::Runtime
	
	  def root
	    @root ||= :zone
	  end
	
	  module Zone0
	    def soa
	      elements[1]
	    end
	
	  end
	
	  module Zone1
	    def variables
	      @variables ||= begin
	        raw = elements[0].elements.select { |e| e.to_s =~ /^\$/ }
	        variables = {}
	        raw.each do |e|
	          variables[e.name.text_value.to_s] = e.value.text_value.to_s
	        end
	        variables
	      end
	    end
	
	    def origin
	      soa.origin.host.to_s
	    end
	
	    def to_s
	      text_value
	    end
	
	    def rr
	      elements[-1].elements.select { |e| e.to_s !~ /\A\s*([;$].*)?\z|\A\z/; }
	    end
	    
	    def entries
	      elements[0].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; } +
	        [soa] +
	        elements[-1].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; }
	    end
	  end
	
	  def _nt_zone
	    start_index = index
	    if node_cache[:zone].has_key?(index)
	      cached = node_cache[:zone][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    s1, i1 = [], index
	    loop do
	      i2 = index
	      r3 = _nt_variable
	      if r3
	        r2 = r3
	      else
	        r4 = _nt_space_or_break
	        if r4
	          r2 = r4
	        else
	          r5 = _nt_comment
	          if r5
	            r2 = r5
	          else
	            @index = i2
	            r2 = nil
	          end
	        end
	      end
	      if r2
	        s1 << r2
	      else
	        break
	      end
	    end
	    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
	    s0 << r1
	    if r1
	      r6 = _nt_soa
	      s0 << r6
	      if r6
	        s7, i7 = [], index
	        loop do
	          i8 = index
	          r9 = _nt_resource_record
	          if r9
	            r8 = r9
	          else
	            r10 = _nt_variable
	            if r10
	              r8 = r10
	            else
	              r11 = _nt_comment
	              if r11
	                r8 = r11
	              else
	                r12 = _nt_space
	                if r12
	                  r8 = r12
	                else
	                  r13 = _nt_linebreak
	                  if r13
	                    r8 = r13
	                  else
	                    @index = i8
	                    r8 = nil
	                  end
	                end
	              end
	            end
	          end
	          if r8
	            s7 << r8
	          else
	            break
	          end
	        end
	        r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
	        s0 << r7
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Zone0)
	      r0.extend(Zone1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:zone][start_index] = r0
	
	    r0
	  end
	
	  module Variable0
	    def name
	      elements[1]
	    end
	
	    def space
	      elements[2]
	    end
	
	    def value
	      elements[3]
	    end
	
	  end
	
	  module Variable1
	    def to_s
	      "$#{name.text_value.to_s} #{value.text_value.to_s}"
	    end
	
	    def parse_type ; :variable ; end
	  end
	
	  def _nt_variable
	    start_index = index
	    if node_cache[:variable].has_key?(index)
	      cached = node_cache[:variable][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    if has_terminal?("$", false, index)
	      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
	      @index += 1
	    else
	      terminal_parse_failure("$")
	      r1 = nil
	    end
	    s0 << r1
	    if r1
	      s2, i2 = [], index
	      loop do
	        if has_terminal?('\G[a-zA-Z0-9]', true, index)
	          r3 = true
	          @index += 1
	        else
	          r3 = nil
	        end
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      if s2.empty?
	        @index = i2
	        r2 = nil
	      else
	        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      end
	      s0 << r2
	      if r2
	        r4 = _nt_space
	        s0 << r4
	        if r4
	          s5, i5 = [], index
	          loop do
	            if has_terminal?('\G[a-zA-Z0-9\\.\\-]', true, index)
	              r6 = true
	              @index += 1
	            else
	              r6 = nil
	            end
	            if r6
	              s5 << r6
	            else
	              break
	            end
	          end
	          if s5.empty?
	            @index = i5
	            r5 = nil
	          else
	            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
	          end
	          s0 << r5
	          if r5
	            r8 = _nt_space
	            if r8
	              r7 = r8
	            else
	              r7 = instantiate_node(SyntaxNode,input, index...index)
	            end
	            s0 << r7
	            if r7
	              r10 = _nt_comment
	              if r10
	                r9 = r10
	              else
	                r9 = instantiate_node(SyntaxNode,input, index...index)
	              end
	              s0 << r9
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Variable0)
	      r0.extend(Variable1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:variable][start_index] = r0
	
	    r0
	  end
	
	  module Soa0
	    def origin
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def ns
	      elements[6]
	    end
	
	    def space3
	      elements[7]
	    end
	
	    def rp
	      elements[8]
	    end
	
	    def space4
	      elements[9]
	    end
	
	    def serial
	      elements[12]
	    end
	
	    def space_or_break1
	      elements[13]
	    end
	
	    def refresh
	      elements[14]
	    end
	
	    def space_or_break2
	      elements[15]
	    end
	
	    def reretry
	      elements[16]
	    end
	
	    def space_or_break3
	      elements[17]
	    end
	
	    def expiry
	      elements[18]
	    end
	
	    def space_or_break4
	      elements[19]
	    end
	
	    def nxttl
	      elements[20]
	    end
	
	  end
	
	  module Soa1
	    def to_s
	      "#{origin} #{ttl} #{klass} SOA #{ns} #{rp} (#{serial} #{refresh} #{reretry} #{expiry} #{nxttl})"
	    end
	    
	    def parse_type ; :soa ; end
	  end
	
	  def _nt_soa
	    start_index = index
	    if node_cache[:soa].has_key?(index)
	      cached = node_cache[:soa][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_origin
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("SOA", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 3))
	              @index += 3
	            else
	              terminal_parse_failure("SOA")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_ns
	                s0 << r7
	                if r7
	                  r8 = _nt_space
	                  s0 << r8
	                  if r8
	                    r9 = _nt_rp
	                    s0 << r9
	                    if r9
	                      r10 = _nt_space
	                      s0 << r10
	                      if r10
	                        if has_terminal?("(", false, index)
	                          r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                          @index += 1
	                        else
	                          terminal_parse_failure("(")
	                          r12 = nil
	                        end
	                        if r12
	                          r11 = r12
	                        else
	                          r11 = instantiate_node(SyntaxNode,input, index...index)
	                        end
	                        s0 << r11
	                        if r11
	                          s13, i13 = [], index
	                          loop do
	                            r14 = _nt_space_or_break
	                            if r14
	                              s13 << r14
	                            else
	                              break
	                            end
	                          end
	                          r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
	                          s0 << r13
	                          if r13
	                            r15 = _nt_serial
	                            s0 << r15
	                            if r15
	                              r16 = _nt_space_or_break
	                              s0 << r16
	                              if r16
	                                r17 = _nt_refresh
	                                s0 << r17
	                                if r17
	                                  r18 = _nt_space_or_break
	                                  s0 << r18
	                                  if r18
	                                    r19 = _nt_reretry
	                                    s0 << r19
	                                    if r19
	                                      r20 = _nt_space_or_break
	                                      s0 << r20
	                                      if r20
	                                        r21 = _nt_expiry
	                                        s0 << r21
	                                        if r21
	                                          r22 = _nt_space_or_break
	                                          s0 << r22
	                                          if r22
	                                            r23 = _nt_nxttl
	                                            s0 << r23
	                                            if r23
	                                              s24, i24 = [], index
	                                              loop do
	                                                r25 = _nt_space_or_break
	                                                if r25
	                                                  s24 << r25
	                                                else
	                                                  break
	                                                end
	                                              end
	                                              r24 = instantiate_node(SyntaxNode,input, i24...index, s24)
	                                              s0 << r24
	                                              if r24
	                                                if has_terminal?(")", false, index)
	                                                  r27 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                                                  @index += 1
	                                                else
	                                                  terminal_parse_failure(")")
	                                                  r27 = nil
	                                                end
	                                                if r27
	                                                  r26 = r27
	                                                else
	                                                  r26 = instantiate_node(SyntaxNode,input, index...index)
	                                                end
	                                                s0 << r26
	                                              end
	                                            end
	                                          end
	                                        end
	                                      end
	                                    end
	                                  end
	                                end
	                              end
	                            end
	                          end
	                        end
	                      end
	                    end
	                  end
	                end
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Soa0)
	      r0.extend(Soa1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:soa][start_index] = r0
	
	    r0
	  end
	
	  module ResourceRecord0
	    def record
	      elements[0]
	    end
	
	    def linebreak
	      elements[3]
	    end
	  end
	
	  module ResourceRecord1
	    def zone
	      p = parent
	      while p.respond_to?(:parent) && p.parent
	        p = p.parent
	      end
	      p
	    end
	    
	    def to_s
	      text_value
	    end
	
	    def record_type
	      record.elements[4].text_value
	    end
	    
	    def ttl
	      record.ttl || zone.variables['TTL'].to_i
	    end
	
	    def method_missing(method_name, *args)
	      if record.respond_to?(method_name)
	        record.send(method_name, *args)
	      end
	    end
	
	    def respond_to?(method_name)
	      super || record.respond_to?(method_name)
	    end
	
	    def parse_type ; :record ; end
	  end
	
	  def _nt_resource_record
	    start_index = index
	    if node_cache[:resource_record].has_key?(index)
	      cached = node_cache[:resource_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    i1 = index
	    r2 = _nt_a_record
	    if r2
	      r1 = r2
	    else
	      r3 = _nt_aaaa_record
	      if r3
	        r1 = r3
	      else
	        r4 = _nt_cname_record
	        if r4
	          r1 = r4
	        else
	          r5 = _nt_mx_record
	          if r5
	            r1 = r5
	          else
	            r6 = _nt_naptr_record
	            if r6
	              r1 = r6
	            else
	              r7 = _nt_ns_record
	              if r7
	                r1 = r7
	              else
	                r8 = _nt_ptr_record
	                if r8
	                  r1 = r8
	                else
	                  r9 = _nt_srv_record
	                  if r9
	                    r1 = r9
	                  else
	                    r10 = _nt_spf_record
	                    if r10
	                      r1 = r10
	                    else
	                      r11 = _nt_txt_record
	                      if r11
	                        r1 = r11
	                      else
	                        @index = i1
	                        r1 = nil
	                      end
	                    end
	                  end
	                end
	              end
	            end
	          end
	        end
	      end
	    end
	    s0 << r1
	    if r1
	      s12, i12 = [], index
	      loop do
	        r13 = _nt_space
	        if r13
	          s12 << r13
	        else
	          break
	        end
	      end
	      r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
	      s0 << r12
	      if r12
	        r15 = _nt_comment
	        if r15
	          r14 = r15
	        else
	          r14 = instantiate_node(SyntaxNode,input, index...index)
	        end
	        s0 << r14
	        if r14
	          r16 = _nt_linebreak
	          s0 << r16
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(ResourceRecord0)
	      r0.extend(ResourceRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:resource_record][start_index] = r0
	
	    r0
	  end
	
	  module ARecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def ip_address
	      elements[6]
	    end
	  end
	
	  module ARecord1
	    def to_s
	      "#{host} #{ttl} #{klass} A #{ip_address}"
	    end
	  end
	
	  def _nt_a_record
	    start_index = index
	    if node_cache[:a_record].has_key?(index)
	      cached = node_cache[:a_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("A", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
	              @index += 1
	            else
	              terminal_parse_failure("A")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_ip_address
	                s0 << r7
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(ARecord0)
	      r0.extend(ARecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:a_record][start_index] = r0
	
	    r0
	  end
	
	  module IpAddress0
	  end
	
	  module IpAddress1
	    def to_s
	      text_value
	    end
	  end
	
	  def _nt_ip_address
	    start_index = index
	    if node_cache[:ip_address].has_key?(index)
	      cached = node_cache[:ip_address][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    s1, i1 = [], index
	    loop do
	      if has_terminal?('\G[\\d]', true, index)
	        r2 = true
	        @index += 1
	      else
	        r2 = nil
	      end
	      if r2
	        s1 << r2
	      else
	        break
	      end
	    end
	    if s1.empty?
	      @index = i1
	      r1 = nil
	    else
	      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
	    end
	    s0 << r1
	    if r1
	      if has_terminal?(".", false, index)
	        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
	        @index += 1
	      else
	        terminal_parse_failure(".")
	        r3 = nil
	      end
	      s0 << r3
	      if r3
	        s4, i4 = [], index
	        loop do
	          if has_terminal?('\G[\\d]', true, index)
	            r5 = true
	            @index += 1
	          else
	            r5 = nil
	          end
	          if r5
	            s4 << r5
	          else
	            break
	          end
	        end
	        if s4.empty?
	          @index = i4
	          r4 = nil
	        else
	          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
	        end
	        s0 << r4
	        if r4
	          if has_terminal?(".", false, index)
	            r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
	            @index += 1
	          else
	            terminal_parse_failure(".")
	            r6 = nil
	          end
	          s0 << r6
	          if r6
	            s7, i7 = [], index
	            loop do
	              if has_terminal?('\G[\\d]', true, index)
	                r8 = true
	                @index += 1
	              else
	                r8 = nil
	              end
	              if r8
	                s7 << r8
	              else
	                break
	              end
	            end
	            if s7.empty?
	              @index = i7
	              r7 = nil
	            else
	              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
	            end
	            s0 << r7
	            if r7
	              if has_terminal?(".", false, index)
	                r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                @index += 1
	              else
	                terminal_parse_failure(".")
	                r9 = nil
	              end
	              s0 << r9
	              if r9
	                s10, i10 = [], index
	                loop do
	                  if has_terminal?('\G[\\d]', true, index)
	                    r11 = true
	                    @index += 1
	                  else
	                    r11 = nil
	                  end
	                  if r11
	                    s10 << r11
	                  else
	                    break
	                  end
	                end
	                if s10.empty?
	                  @index = i10
	                  r10 = nil
	                else
	                  r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
	                end
	                s0 << r10
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(IpAddress0)
	      r0.extend(IpAddress1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:ip_address][start_index] = r0
	
	    r0
	  end
	
	  module AaaaRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def ip_address
	      elements[6]
	    end
	  end
	
	  module AaaaRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} AAAA #{ip_address}"
	    end
	  end
	
	  def _nt_aaaa_record
	    start_index = index
	    if node_cache[:aaaa_record].has_key?(index)
	      cached = node_cache[:aaaa_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("AAAA", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 4))
	              @index += 4
	            else
	              terminal_parse_failure("AAAA")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_ip6_address
	                s0 << r7
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(AaaaRecord0)
	      r0.extend(AaaaRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:aaaa_record][start_index] = r0
	
	    r0
	  end
	
	  module Ip6Address0
	    def to_s
	      text_value.downcase
	    end
	  end
	
	  def _nt_ip6_address
	    start_index = index
	    if node_cache[:ip6_address].has_key?(index)
	      cached = node_cache[:ip6_address][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    s0, i0 = [], index
	    loop do
	      if has_terminal?('\G[\\da-fA-F:.]', true, index)
	        r1 = true
	        @index += 1
	      else
	        r1 = nil
	      end
	      if r1
	        s0 << r1
	      else
	        break
	      end
	      if s0.size == 39
	        break
	      end
	    end
	    if s0.size < 2
	      @index = i0
	      r0 = nil
	    else
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Ip6Address0)
	    end
	
	    node_cache[:ip6_address][start_index] = r0
	
	    r0
	  end
	
	  module CnameRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def target
	      elements[6]
	    end
	  end
	
	  module CnameRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} CNAME #{target}"
	    end
	  end
	
	  def _nt_cname_record
	    start_index = index
	    if node_cache[:cname_record].has_key?(index)
	      cached = node_cache[:cname_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("CNAME", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 5))
	              @index += 5
	            else
	              terminal_parse_failure("CNAME")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_host
	                s0 << r7
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(CnameRecord0)
	      r0.extend(CnameRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:cname_record][start_index] = r0
	
	    r0
	  end
	
	  module MxRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def priority
	      elements[6]
	    end
	
	    def space3
	      elements[7]
	    end
	
	    def exchanger
	      elements[8]
	    end
	  end
	
	  module MxRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} MX #{priority} #{exchanger}"
	    end
	  end
	
	  def _nt_mx_record
	    start_index = index
	    if node_cache[:mx_record].has_key?(index)
	      cached = node_cache[:mx_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("MX", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 2))
	              @index += 2
	            else
	              terminal_parse_failure("MX")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_integer
	                s0 << r7
	                if r7
	                  r8 = _nt_space
	                  s0 << r8
	                  if r8
	                    r9 = _nt_host
	                    s0 << r9
	                  end
	                end
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(MxRecord0)
	      r0.extend(MxRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:mx_record][start_index] = r0
	
	    r0
	  end
	
	  module NaptrRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def data
	      elements[6]
	    end
	  end
	
	  module NaptrRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} NAPTR #{data}"
	    end
	  end
	
	  def _nt_naptr_record
	    start_index = index
	    if node_cache[:naptr_record].has_key?(index)
	      cached = node_cache[:naptr_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("NAPTR", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 5))
	              @index += 5
	            else
	              terminal_parse_failure("NAPTR")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_data
	                s0 << r7
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(NaptrRecord0)
	      r0.extend(NaptrRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:naptr_record][start_index] = r0
	
	    r0
	  end
	
	  module NsRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def nameserver
	      elements[6]
	    end
	  end
	
	  module NsRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} NS #{nameserver}"
	    end
	  end
	
	  def _nt_ns_record
	    start_index = index
	    if node_cache[:ns_record].has_key?(index)
	      cached = node_cache[:ns_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("NS", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 2))
	              @index += 2
	            else
	              terminal_parse_failure("NS")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_host
	                s0 << r7
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(NsRecord0)
	      r0.extend(NsRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:ns_record][start_index] = r0
	
	    r0
	  end
	
	  module PtrRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def target
	      elements[6]
	    end
	  end
	
	  module PtrRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} PTR #{target}"
	    end
	  end
	
	  def _nt_ptr_record
	    start_index = index
	    if node_cache[:ptr_record].has_key?(index)
	      cached = node_cache[:ptr_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("PTR", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 3))
	              @index += 3
	            else
	              terminal_parse_failure("PTR")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_host
	                s0 << r7
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(PtrRecord0)
	      r0.extend(PtrRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:ptr_record][start_index] = r0
	
	    r0
	  end
	
	  module SrvRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def priority
	      elements[6]
	    end
	
	    def space3
	      elements[7]
	    end
	
	    def weight
	      elements[8]
	    end
	
	    def space4
	      elements[9]
	    end
	
	    def port
	      elements[10]
	    end
	
	    def space5
	      elements[11]
	    end
	
	    def target
	      elements[12]
	    end
	  end
	
	  module SrvRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} SRV #{priority} #{weight} #{port} #{target}"
	    end
	  end
	
	  def _nt_srv_record
	    start_index = index
	    if node_cache[:srv_record].has_key?(index)
	      cached = node_cache[:srv_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("SRV", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 3))
	              @index += 3
	            else
	              terminal_parse_failure("SRV")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_integer
	                s0 << r7
	                if r7
	                  r8 = _nt_space
	                  s0 << r8
	                  if r8
	                    r9 = _nt_integer
	                    s0 << r9
	                    if r9
	                      r10 = _nt_space
	                      s0 << r10
	                      if r10
	                        r11 = _nt_integer
	                        s0 << r11
	                        if r11
	                          r12 = _nt_space
	                          s0 << r12
	                          if r12
	                            r13 = _nt_host
	                            s0 << r13
	                          end
	                        end
	                      end
	                    end
	                  end
	                end
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(SrvRecord0)
	      r0.extend(SrvRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:srv_record][start_index] = r0
	
	    r0
	  end
	
	  module SpfRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def data
	      elements[6]
	    end
	  end
	
	  module SpfRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} SPF #{data}"
	    end
	  end
	
	  def _nt_spf_record
	    start_index = index
	    if node_cache[:spf_record].has_key?(index)
	      cached = node_cache[:spf_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("SPF", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 3))
	              @index += 3
	            else
	              terminal_parse_failure("SPF")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_txt_data
	                s0 << r7
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(SpfRecord0)
	      r0.extend(SpfRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:spf_record][start_index] = r0
	
	    r0
	  end
	
	  module TxtRecord0
	    def host
	      elements[0]
	    end
	
	    def space1
	      elements[1]
	    end
	
	    def ttl
	      elements[2]
	    end
	
	    def klass
	      elements[3]
	    end
	
	    def space2
	      elements[5]
	    end
	
	    def data
	      elements[6]
	    end
	  end
	
	  module TxtRecord1
	    def to_s
	      "#{host} #{ttl} #{klass} TXT #{data}"
	    end
	  end
	
	  def _nt_txt_record
	    start_index = index
	    if node_cache[:txt_record].has_key?(index)
	      cached = node_cache[:txt_record][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      r2 = _nt_space
	      s0 << r2
	      if r2
	        r3 = _nt_ttl
	        s0 << r3
	        if r3
	          r4 = _nt_klass
	          s0 << r4
	          if r4
	            if has_terminal?("TXT", false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 3))
	              @index += 3
	            else
	              terminal_parse_failure("TXT")
	              r5 = nil
	            end
	            s0 << r5
	            if r5
	              r6 = _nt_space
	              s0 << r6
	              if r6
	                r7 = _nt_txt_data
	                s0 << r7
	              end
	            end
	          end
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(TxtRecord0)
	      r0.extend(TxtRecord1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:txt_record][start_index] = r0
	
	    r0
	  end
	
	  module Origin0
	    def host
	      elements[0]
	    end
	
	  end
	
	  module Origin1
	    def to_s
	      "#{host}"
	    end
	  end
	
	  def _nt_origin
	    start_index = index
	    if node_cache[:origin].has_key?(index)
	      cached = node_cache[:origin][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      s2, i2 = [], index
	      loop do
	        r3 = _nt_comment
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      s0 << r2
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Origin0)
	      r0.extend(Origin1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:origin][start_index] = r0
	
	    r0
	  end
	
	  module Space0
	    def to_s
	      text_value
	    end
	  end
	
	  def _nt_space
	    start_index = index
	    if node_cache[:space].has_key?(index)
	      cached = node_cache[:space][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    s0, i0 = [], index
	    loop do
	      if has_terminal?('\G[ \\t]', true, index)
	        r1 = true
	        @index += 1
	      else
	        r1 = nil
	      end
	      if r1
	        s0 << r1
	      else
	        break
	      end
	    end
	    if s0.empty?
	      @index = i0
	      r0 = nil
	    else
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Space0)
	    end
	
	    node_cache[:space][start_index] = r0
	
	    r0
	  end
	
	  module Linebreak0
	    def to_s
	      ''
	    end
	  end
	
	  def _nt_linebreak
	    start_index = index
	    if node_cache[:linebreak].has_key?(index)
	      cached = node_cache[:linebreak][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    s0, i0 = [], index
	    loop do
	      if has_terminal?('\G[\\n\\r]', true, index)
	        r1 = true
	        @index += 1
	      else
	        r1 = nil
	      end
	      if r1
	        s0 << r1
	      else
	        break
	      end
	    end
	    if s0.empty?
	      @index = i0
	      r0 = nil
	    else
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Linebreak0)
	    end
	
	    node_cache[:linebreak][start_index] = r0
	
	    r0
	  end
	
	  module SpaceOrBreak0
	    def to_s
	      text_value
	    end
	  end
	
	  def _nt_space_or_break
	    start_index = index
	    if node_cache[:space_or_break].has_key?(index)
	      cached = node_cache[:space_or_break][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    s0, i0 = [], index
	    loop do
	      if has_terminal?('\G[\\s]', true, index)
	        r1 = true
	        @index += 1
	      else
	        r1 = nil
	      end
	      if r1
	        s0 << r1
	      else
	        break
	      end
	    end
	    if s0.empty?
	      @index = i0
	      r0 = nil
	    else
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(SpaceOrBreak0)
	    end
	
	    node_cache[:space_or_break][start_index] = r0
	
	    r0
	  end
	
	  module Klass0
	    def space
	      elements[1]
	    end
	  end
	
	  module Klass1
	    def to_s
	      text_value.strip
	    end
	  end
	
	  def _nt_klass
	    start_index = index
	    if node_cache[:klass].has_key?(index)
	      cached = node_cache[:klass][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0 = index
	    i1, s1 = index, []
	    if has_terminal?("IN", false, index)
	      r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
	      @index += 2
	    else
	      terminal_parse_failure("IN")
	      r2 = nil
	    end
	    s1 << r2
	    if r2
	      r3 = _nt_space
	      s1 << r3
	    end
	    if s1.last
	      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
	      r1.extend(Klass0)
	    else
	      @index = i1
	      r1 = nil
	    end
	    if r1
	      r0 = r1
	      r0.extend(Klass1)
	    else
	      if has_terminal?('', false, index)
	        r4 = instantiate_node(SyntaxNode,input, index...(index + 0))
	        @index += 0
	      else
	        terminal_parse_failure('')
	        r4 = nil
	      end
	      if r4
	        r0 = r4
	        r0.extend(Klass1)
	      else
	        @index = i0
	        r0 = nil
	      end
	    end
	
	    node_cache[:klass][start_index] = r0
	
	    r0
	  end
	
	  module Comment0
	  end
	
	  module Comment1
	    def to_s
	      text_value.strip
	    end
	  end
	
	  def _nt_comment
	    start_index = index
	    if node_cache[:comment].has_key?(index)
	      cached = node_cache[:comment][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    s1, i1 = [], index
	    loop do
	      r2 = _nt_space
	      if r2
	        s1 << r2
	      else
	        break
	      end
	    end
	    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
	    s0 << r1
	    if r1
	      if has_terminal?(";", false, index)
	        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
	        @index += 1
	      else
	        terminal_parse_failure(";")
	        r3 = nil
	      end
	      s0 << r3
	      if r3
	        s4, i4 = [], index
	        loop do
	          if has_terminal?('\G[^\\n\\r]', true, index)
	            r5 = true
	            @index += 1
	          else
	            r5 = nil
	          end
	          if r5
	            s4 << r5
	          else
	            break
	          end
	        end
	        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
	        s0 << r4
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Comment0)
	      r0.extend(Comment1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:comment][start_index] = r0
	
	    r0
	  end
	
	  module Ns0
	    def host
	      elements[0]
	    end
	
	  end
	
	  module Ns1
	    def to_s
	      "#{host}"
	    end
	  end
	
	  def _nt_ns
	    start_index = index
	    if node_cache[:ns].has_key?(index)
	      cached = node_cache[:ns][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_host
	    s0 << r1
	    if r1
	      s2, i2 = [], index
	      loop do
	        r3 = _nt_comment
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      s0 << r2
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Ns0)
	      r0.extend(Ns1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:ns][start_index] = r0
	
	    r0
	  end
	
	  module Rp0
	  end
	
	  module Rp1
	    def to_s
	      text_value
	    end
	  end
	
	  def _nt_rp
	    start_index = index
	    if node_cache[:rp].has_key?(index)
	      cached = node_cache[:rp][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    s0, i0 = [], index
	    loop do
	      i1, s1 = index, []
	      s2, i2 = [], index
	      loop do
	        if has_terminal?('\G[a-zA-Z0-9\\-]', true, index)
	          r3 = true
	          @index += 1
	        else
	          r3 = nil
	        end
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      if s2.empty?
	        @index = i2
	        r2 = nil
	      else
	        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      end
	      s1 << r2
	      if r2
	        if has_terminal?(".", false, index)
	          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
	          @index += 1
	        else
	          terminal_parse_failure(".")
	          r4 = nil
	        end
	        s1 << r4
	      end
	      if s1.last
	        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
	        r1.extend(Rp0)
	      else
	        @index = i1
	        r1 = nil
	      end
	      if r1
	        s0 << r1
	      else
	        break
	      end
	    end
	    if s0.empty?
	      @index = i0
	      r0 = nil
	    else
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Rp1)
	    end
	
	    node_cache[:rp][start_index] = r0
	
	    r0
	  end
	
	  module Serial0
	    def integer
	      elements[0]
	    end
	
	  end
	
	  module Serial1
	    def to_i
	      integer.to_i
	    end
	    def to_s
	      "#{to_i}"
	    end
	  end
	
	  def _nt_serial
	    start_index = index
	    if node_cache[:serial].has_key?(index)
	      cached = node_cache[:serial][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_integer
	    s0 << r1
	    if r1
	      s2, i2 = [], index
	      loop do
	        r3 = _nt_comment
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      s0 << r2
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Serial0)
	      r0.extend(Serial1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:serial][start_index] = r0
	
	    r0
	  end
	
	  module TimeInterval0
	    def integer
	      elements[0]
	    end
	
	    def time_multiplier
	      elements[1]
	    end
	  end
	
	  module TimeInterval1
	    def to_s
	      text_value
	    end
	
	    def to_i
	      time_multiplier.to_i * integer.to_i
	    end
	  end
	
	  def _nt_time_interval
	    start_index = index
	    if node_cache[:time_interval].has_key?(index)
	      cached = node_cache[:time_interval][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_integer
	    s0 << r1
	    if r1
	      r2 = _nt_time_multiplier
	      s0 << r2
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(TimeInterval0)
	      r0.extend(TimeInterval1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:time_interval][start_index] = r0
	
	    r0
	  end
	
	  module Refresh0
	    def time_interval
	      elements[0]
	    end
	
	  end
	
	  module Refresh1
	    def to_i
	      time_interval.to_i
	    end
	    def to_s
	      time_interval.to_s
	    end
	  end
	
	  def _nt_refresh
	    start_index = index
	    if node_cache[:refresh].has_key?(index)
	      cached = node_cache[:refresh][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_time_interval
	    s0 << r1
	    if r1
	      s2, i2 = [], index
	      loop do
	        r3 = _nt_comment
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      s0 << r2
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Refresh0)
	      r0.extend(Refresh1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:refresh][start_index] = r0
	
	    r0
	  end
	
	  module Integer0
	    def to_i
	      text_value.to_i
	    end
	    def to_s
	      "#{to_i}"
	    end
	  end
	
	  def _nt_integer
	    start_index = index
	    if node_cache[:integer].has_key?(index)
	      cached = node_cache[:integer][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    s0, i0 = [], index
	    loop do
	      if has_terminal?('\G[0-9]', true, index)
	        r1 = true
	        @index += 1
	      else
	        r1 = nil
	      end
	      if r1
	        s0 << r1
	      else
	        break
	      end
	    end
	    if s0.empty?
	      @index = i0
	      r0 = nil
	    else
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Integer0)
	    end
	
	    node_cache[:integer][start_index] = r0
	
	    r0
	  end
	
	  module TimeMultiplier0
	    def to_s
	      text_value
	    end
	    def to_i
	      case text_value.downcase
	        when 'm' then 60
	        when 'h' then 60 * 60
	        when 'd' then 60 * 60 * 24
	        when 'w' then 60 * 60 * 24 * 7
	        else
	          1
	      end
	    end
	  end
	
	  def _nt_time_multiplier
	    start_index = index
	    if node_cache[:time_multiplier].has_key?(index)
	      cached = node_cache[:time_multiplier][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0 = index
	    if has_terminal?('s', false, index)
	      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
	      @index += 1
	    else
	      terminal_parse_failure('s')
	      r1 = nil
	    end
	    if r1
	      r0 = r1
	      r0.extend(TimeMultiplier0)
	    else
	      if has_terminal?('S', false, index)
	        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
	        @index += 1
	      else
	        terminal_parse_failure('S')
	        r2 = nil
	      end
	      if r2
	        r0 = r2
	        r0.extend(TimeMultiplier0)
	      else
	        if has_terminal?('m', false, index)
	          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
	          @index += 1
	        else
	          terminal_parse_failure('m')
	          r3 = nil
	        end
	        if r3
	          r0 = r3
	          r0.extend(TimeMultiplier0)
	        else
	          if has_terminal?('M', false, index)
	            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
	            @index += 1
	          else
	            terminal_parse_failure('M')
	            r4 = nil
	          end
	          if r4
	            r0 = r4
	            r0.extend(TimeMultiplier0)
	          else
	            if has_terminal?('h', false, index)
	              r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
	              @index += 1
	            else
	              terminal_parse_failure('h')
	              r5 = nil
	            end
	            if r5
	              r0 = r5
	              r0.extend(TimeMultiplier0)
	            else
	              if has_terminal?('H', false, index)
	                r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                @index += 1
	              else
	                terminal_parse_failure('H')
	                r6 = nil
	              end
	              if r6
	                r0 = r6
	                r0.extend(TimeMultiplier0)
	              else
	                if has_terminal?('d', false, index)
	                  r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                  @index += 1
	                else
	                  terminal_parse_failure('d')
	                  r7 = nil
	                end
	                if r7
	                  r0 = r7
	                  r0.extend(TimeMultiplier0)
	                else
	                  if has_terminal?('D', false, index)
	                    r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                    @index += 1
	                  else
	                    terminal_parse_failure('D')
	                    r8 = nil
	                  end
	                  if r8
	                    r0 = r8
	                    r0.extend(TimeMultiplier0)
	                  else
	                    if has_terminal?('w', false, index)
	                      r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                      @index += 1
	                    else
	                      terminal_parse_failure('w')
	                      r9 = nil
	                    end
	                    if r9
	                      r0 = r9
	                      r0.extend(TimeMultiplier0)
	                    else
	                      if has_terminal?('W', false, index)
	                        r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                        @index += 1
	                      else
	                        terminal_parse_failure('W')
	                        r10 = nil
	                      end
	                      if r10
	                        r0 = r10
	                        r0.extend(TimeMultiplier0)
	                      else
	                        if has_terminal?('', false, index)
	                          r11 = instantiate_node(SyntaxNode,input, index...(index + 0))
	                          @index += 0
	                        else
	                          terminal_parse_failure('')
	                          r11 = nil
	                        end
	                        if r11
	                          r0 = r11
	                          r0.extend(TimeMultiplier0)
	                        else
	                          @index = i0
	                          r0 = nil
	                        end
	                      end
	                    end
	                  end
	                end
	              end
	            end
	          end
	        end
	      end
	    end
	
	    node_cache[:time_multiplier][start_index] = r0
	
	    r0
	  end
	
	  module Reretry0
	    def time_interval
	      elements[0]
	    end
	
	  end
	
	  module Reretry1
	    def to_i
	      time_interval.to_i
	    end
	    def to_s
	      time_interval.to_s
	    end
	  end
	
	  def _nt_reretry
	    start_index = index
	    if node_cache[:reretry].has_key?(index)
	      cached = node_cache[:reretry][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_time_interval
	    s0 << r1
	    if r1
	      s2, i2 = [], index
	      loop do
	        r3 = _nt_comment
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      s0 << r2
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Reretry0)
	      r0.extend(Reretry1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:reretry][start_index] = r0
	
	    r0
	  end
	
	  module Expiry0
	    def time_interval
	      elements[0]
	    end
	
	  end
	
	  module Expiry1
	    def to_i
	      time_interval.to_i
	    end
	    def to_s
	      time_interval.to_s
	    end
	  end
	
	  def _nt_expiry
	    start_index = index
	    if node_cache[:expiry].has_key?(index)
	      cached = node_cache[:expiry][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_time_interval
	    s0 << r1
	    if r1
	      s2, i2 = [], index
	      loop do
	        r3 = _nt_comment
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      s0 << r2
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Expiry0)
	      r0.extend(Expiry1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:expiry][start_index] = r0
	
	    r0
	  end
	
	  module Nxttl0
	    def time_interval
	      elements[0]
	    end
	
	  end
	
	  module Nxttl1
	    def to_i
	      time_interval.to_i
	    end
	    def to_s
	      time_interval.to_s
	    end
	  end
	
	  def _nt_nxttl
	    start_index = index
	    if node_cache[:nxttl].has_key?(index)
	      cached = node_cache[:nxttl][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    r1 = _nt_time_interval
	    s0 << r1
	    if r1
	      s2, i2 = [], index
	      loop do
	        r3 = _nt_comment
	        if r3
	          s2 << r3
	        else
	          break
	        end
	      end
	      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
	      s0 << r2
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Nxttl0)
	      r0.extend(Nxttl1)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:nxttl][start_index] = r0
	
	    r0
	  end
	
	  module Ttl0
	    def time_interval
	      elements[0]
	    end
	
	    def space
	      elements[1]
	    end
	  end
	
	  module Ttl1
	    def to_i
	      respond_to?(:time_interval) ? time_interval.to_i : nil
	    end
	    def to_s
	      respond_to?(:time_interval) ? time_interval.to_s : ''
	    end
	  end
	
	  def _nt_ttl
	    start_index = index
	    if node_cache[:ttl].has_key?(index)
	      cached = node_cache[:ttl][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0 = index
	    i1, s1 = index, []
	    r2 = _nt_time_interval
	    s1 << r2
	    if r2
	      r3 = _nt_space
	      s1 << r3
	    end
	    if s1.last
	      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
	      r1.extend(Ttl0)
	    else
	      @index = i1
	      r1 = nil
	    end
	    if r1
	      r0 = r1
	      r0.extend(Ttl1)
	    else
	      if has_terminal?('', false, index)
	        r4 = instantiate_node(SyntaxNode,input, index...(index + 0))
	        @index += 0
	      else
	        terminal_parse_failure('')
	        r4 = nil
	      end
	      if r4
	        r0 = r4
	        r0.extend(Ttl1)
	      else
	        @index = i0
	        r0 = nil
	      end
	    end
	
	    node_cache[:ttl][start_index] = r0
	
	    r0
	  end
	
	  module Host0
	    def to_s
	      case text_value
	      when /\.$/
	        text_value
	      when "@", /\s/
	        text_value
	      else
	        text_value + '.@'
	      end
	    end
	  end
	
	  def _nt_host
	    start_index = index
	    if node_cache[:host].has_key?(index)
	      cached = node_cache[:host][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0 = index
	    s1, i1 = [], index
	    loop do
	      if has_terminal?('\G[*a-zA-Z0-9\\-\\._]', true, index)
	        r2 = true
	        @index += 1
	      else
	        r2 = nil
	      end
	      if r2
	        s1 << r2
	      else
	        break
	      end
	    end
	    if s1.empty?
	      @index = i1
	      r1 = nil
	    else
	      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
	    end
	    if r1
	      r0 = r1
	      r0.extend(Host0)
	    else
	      if has_terminal?("@", false, index)
	        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
	        @index += 1
	      else
	        terminal_parse_failure("@")
	        r3 = nil
	      end
	      if r3
	        r0 = r3
	        r0.extend(Host0)
	      else
	        if has_terminal?(' ', false, index)
	          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
	          @index += 1
	        else
	          terminal_parse_failure(' ')
	          r4 = nil
	        end
	        if r4
	          r0 = r4
	          r0.extend(Host0)
	        else
	          if has_terminal?("\t", false, index)
	            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
	            @index += 1
	          else
	            terminal_parse_failure("\t")
	            r5 = nil
	          end
	          if r5
	            r0 = r5
	            r0.extend(Host0)
	          else
	            @index = i0
	            r0 = nil
	          end
	        end
	      end
	    end
	
	    node_cache[:host][start_index] = r0
	
	    r0
	  end
	
	  module Data0
	    def to_s
	      text_value.strip
	    end
	  end
	
	  def _nt_data
	    start_index = index
	    if node_cache[:data].has_key?(index)
	      cached = node_cache[:data][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    s0, i0 = [], index
	    loop do
	      if has_terminal?('\G[^;\\n\\r]', true, index)
	        r1 = true
	        @index += 1
	      else
	        r1 = nil
	      end
	      if r1
	        s0 << r1
	      else
	        break
	      end
	    end
	    if s0.empty?
	      @index = i0
	      r0 = nil
	    else
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(Data0)
	    end
	
	    node_cache[:data][start_index] = r0
	
	    r0
	  end
	
	  module TxtData0
	  end
	
	  module TxtData1
	  end
	
	  module TxtData2
	    def space
	      elements[0]
	    end
	
	  end
	
	  module TxtData3
	  end
	
	  module TxtData4
	    def to_s
	      text_value
	    end
	  end
	
	  def _nt_txt_data
	    start_index = index
	    if node_cache[:txt_data].has_key?(index)
	      cached = node_cache[:txt_data][index]
	      if cached
	        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
	        @index = cached.interval.end
	      end
	      return cached
	    end
	
	    i0, s0 = index, []
	    if has_terminal?('"', false, index)
	      r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
	      @index += 1
	    else
	      terminal_parse_failure('"')
	      r2 = nil
	    end
	    if r2
	      r1 = r2
	    else
	      r1 = instantiate_node(SyntaxNode,input, index...index)
	    end
	    s0 << r1
	    if r1
	      s3, i3 = [], index
	      loop do
	        i4 = index
	        if has_terminal?('\\"', false, index)
	          r5 = instantiate_node(SyntaxNode,input, index...(index + 2))
	          @index += 2
	        else
	          terminal_parse_failure('\\"')
	          r5 = nil
	        end
	        if r5
	          r4 = r5
	        else
	          i6, s6 = index, []
	          i7 = index
	          if has_terminal?('"', false, index)
	            r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
	            @index += 1
	          else
	            terminal_parse_failure('"')
	            r8 = nil
	          end
	          if r8
	            r7 = nil
	          else
	            @index = i7
	            r7 = instantiate_node(SyntaxNode,input, index...index)
	          end
	          s6 << r7
	          if r7
	            if has_terminal?('\G[^\\n\\r]', true, index)
	              r9 = true
	              @index += 1
	            else
	              r9 = nil
	            end
	            s6 << r9
	          end
	          if s6.last
	            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
	            r6.extend(TxtData0)
	          else
	            @index = i6
	            r6 = nil
	          end
	          if r6
	            r4 = r6
	          else
	            @index = i4
	            r4 = nil
	          end
	        end
	        if r4
	          s3 << r4
	        else
	          break
	        end
	      end
	      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
	      s0 << r3
	      if r3
	        if has_terminal?('"', false, index)
	          r11 = instantiate_node(SyntaxNode,input, index...(index + 1))
	          @index += 1
	        else
	          terminal_parse_failure('"')
	          r11 = nil
	        end
	        if r11
	          r10 = r11
	        else
	          r10 = instantiate_node(SyntaxNode,input, index...index)
	        end
	        s0 << r10
	        if r10
	          s12, i12 = [], index
	          loop do
	            i13, s13 = index, []
	            r14 = _nt_space
	            s13 << r14
	            if r14
	              if has_terminal?('"', false, index)
	                r15 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                @index += 1
	              else
	                terminal_parse_failure('"')
	                r15 = nil
	              end
	              s13 << r15
	              if r15
	                s16, i16 = [], index
	                loop do
	                  i17 = index
	                  if has_terminal?('\\"', false, index)
	                    r18 = instantiate_node(SyntaxNode,input, index...(index + 2))
	                    @index += 2
	                  else
	                    terminal_parse_failure('\\"')
	                    r18 = nil
	                  end
	                  if r18
	                    r17 = r18
	                  else
	                    i19, s19 = index, []
	                    i20 = index
	                    if has_terminal?('"', false, index)
	                      r21 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                      @index += 1
	                    else
	                      terminal_parse_failure('"')
	                      r21 = nil
	                    end
	                    if r21
	                      r20 = nil
	                    else
	                      @index = i20
	                      r20 = instantiate_node(SyntaxNode,input, index...index)
	                    end
	                    s19 << r20
	                    if r20
	                      if has_terminal?('\G[^\\n\\r]', true, index)
	                        r22 = true
	                        @index += 1
	                      else
	                        r22 = nil
	                      end
	                      s19 << r22
	                    end
	                    if s19.last
	                      r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
	                      r19.extend(TxtData1)
	                    else
	                      @index = i19
	                      r19 = nil
	                    end
	                    if r19
	                      r17 = r19
	                    else
	                      @index = i17
	                      r17 = nil
	                    end
	                  end
	                  if r17
	                    s16 << r17
	                  else
	                    break
	                  end
	                end
	                r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
	                s13 << r16
	                if r16
	                  if has_terminal?('"', false, index)
	                    r23 = instantiate_node(SyntaxNode,input, index...(index + 1))
	                    @index += 1
	                  else
	                    terminal_parse_failure('"')
	                    r23 = nil
	                  end
	                  s13 << r23
	                end
	              end
	            end
	            if s13.last
	              r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
	              r13.extend(TxtData2)
	            else
	              @index = i13
	              r13 = nil
	            end
	            if r13
	              s12 << r13
	            else
	              break
	            end
	          end
	          r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
	          s0 << r12
	        end
	      end
	    end
	    if s0.last
	      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
	      r0.extend(TxtData3)
	      r0.extend(TxtData4)
	    else
	      @index = i0
	      r0 = nil
	    end
	
	    node_cache[:txt_data][start_index] = r0
	
	    r0
	  end
	
	end
	
	class ZonefileParser < Treetop::Runtime::CompiledParser
	  include ZonefileGrammar # :nodoc:
	end
end