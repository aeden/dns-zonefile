require 'treetop'

module DNS
  module Zonefile
    # Autogenerated from a Treetop grammar. Edits may be lost.


    module ZonefileGrammar # :nodoc:
      include Treetop::Runtime

      def root
        @root ||= :zone
      end

      module Zone0
        def soa
          elements[1]
        end

      end

      module Zone1
        def variables
          @variables ||= begin
            raw = elements[0].elements.select { |e| e.to_s =~ /^\$/ }
            variables = {}
            raw.each do |e|
              variables[e.name.text_value.to_s] = e.value.text_value.to_s
            end
            variables
          end
        end

        def origin
          soa.origin.host.to_s
        end

        def to_s
          text_value
        end

        def rr
          elements[-1].elements.select { |e| e.to_s !~ /\A\s*([;$].*)?\z|\A\z/; }
        end

        def entries
          elements[0].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; } +
            [soa] +
            elements[-1].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; }
        end
      end

      def _nt_zone
        start_index = index
        if node_cache[:zone].has_key?(index)
          cached = node_cache[:zone][index]
          if cached
            node_cache[:zone][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          i2 = index
          r3 = _nt_variable
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r2 = r3
          else
            r4 = _nt_space_or_break
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r2 = r4
            else
              r5 = _nt_comment
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r2 = r5
              else
                @index = i2
                r2 = nil
              end
            end
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          r6 = _nt_soa
          s0 << r6
          if r6
            s7, i7 = [], index
            loop do
              i8 = index
              r9 = _nt_resource_record
              if r9
                r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                r8 = r9
              else
                r10 = _nt_variable
                if r10
                  r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                  r8 = r10
                else
                  r11 = _nt_comment
                  if r11
                    r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                    r8 = r11
                  else
                    r12 = _nt_space
                    if r12
                      r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                      r8 = r12
                    else
                      r13 = _nt_linebreak
                      if r13
                        r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                        r8 = r13
                      else
                        @index = i8
                        r8 = nil
                      end
                    end
                  end
                end
              end
              if r8
                s7 << r8
              else
                break
              end
            end
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            s0 << r7
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Zone0)
          r0.extend(Zone1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:zone][start_index] = r0

        r0
      end

      module Variable0
        def name
          elements[1]
        end

        def space
          elements[2]
        end

        def value
          elements[3]
        end

      end

      module Variable1
        def to_s
          "$#{name.text_value.to_s} #{value.text_value.to_s}"
        end

        def parse_type ; :variable ; end
      end

      def _nt_variable
        start_index = index
        if node_cache[:variable].has_key?(index)
          cached = node_cache[:variable][index]
          if cached
            node_cache[:variable][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("$", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"$"')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[a-zA-Z0-9]')
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
          if r2
            r4 = _nt_space
            s0 << r4
            if r4
              s5, i5 = [], index
              loop do
                if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9\\.\\-]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[a-zA-Z0-9\\.\\-]')
                  r6 = nil
                end
                if r6
                  s5 << r6
                else
                  break
                end
              end
              if s5.empty?
                @index = i5
                r5 = nil
              else
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              end
              s0 << r5
              if r5
                r8 = _nt_space
                if r8
                  r7 = r8
                else
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r7
                if r7
                  r10 = _nt_comment
                  if r10
                    r9 = r10
                  else
                    r9 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r9
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Variable0)
          r0.extend(Variable1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:variable][start_index] = r0

        r0
      end

      module Soa0
        def origin
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def ns
          elements[6]
        end

        def space3
          elements[7]
        end

        def rp
          elements[8]
        end

        def space4
          elements[9]
        end

        def serial
          elements[12]
        end

        def space_or_break1
          elements[13]
        end

        def refresh
          elements[14]
        end

        def space_or_break2
          elements[15]
        end

        def reretry
          elements[16]
        end

        def space_or_break3
          elements[17]
        end

        def expiry
          elements[18]
        end

        def space_or_break4
          elements[19]
        end

        def nxttl
          elements[20]
        end

      end

      module Soa1
        def to_s
          "#{origin} #{ttl} #{klass} SOA #{ns} #{rp} (#{serial} #{refresh} #{reretry} #{expiry} #{nxttl})"
        end

        def parse_type ; :soa ; end
      end

      def _nt_soa
        start_index = index
        if node_cache[:soa].has_key?(index)
          cached = node_cache[:soa][index]
          if cached
            node_cache[:soa][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_origin
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("SOA", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"SOA"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_ns
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                      if r8
                        r9 = _nt_rp
                        s0 << r9
                        if r9
                          r10 = _nt_space
                          s0 << r10
                          if r10
                            if (match_len = has_terminal?("(", false, index))
                              r12 = true
                              @index += match_len
                            else
                              terminal_parse_failure('"("')
                              r12 = nil
                            end
                            if r12
                              r11 = r12
                            else
                              r11 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s0 << r11
                            if r11
                              s13, i13 = [], index
                              loop do
                                r14 = _nt_space_or_break
                                if r14
                                  s13 << r14
                                else
                                  break
                                end
                              end
                              r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                              s0 << r13
                              if r13
                                r15 = _nt_serial
                                s0 << r15
                                if r15
                                  r16 = _nt_space_or_break
                                  s0 << r16
                                  if r16
                                    r17 = _nt_refresh
                                    s0 << r17
                                    if r17
                                      r18 = _nt_space_or_break
                                      s0 << r18
                                      if r18
                                        r19 = _nt_reretry
                                        s0 << r19
                                        if r19
                                          r20 = _nt_space_or_break
                                          s0 << r20
                                          if r20
                                            r21 = _nt_expiry
                                            s0 << r21
                                            if r21
                                              r22 = _nt_space_or_break
                                              s0 << r22
                                              if r22
                                                r23 = _nt_nxttl
                                                s0 << r23
                                                if r23
                                                  s24, i24 = [], index
                                                  loop do
                                                    r25 = _nt_space_or_break
                                                    if r25
                                                      s24 << r25
                                                    else
                                                      break
                                                    end
                                                  end
                                                  r24 = instantiate_node(SyntaxNode,input, i24...index, s24)
                                                  s0 << r24
                                                  if r24
                                                    if (match_len = has_terminal?(")", false, index))
                                                      r27 = true
                                                      @index += match_len
                                                    else
                                                      terminal_parse_failure('")"')
                                                      r27 = nil
                                                    end
                                                    if r27
                                                      r26 = r27
                                                    else
                                                      r26 = instantiate_node(SyntaxNode,input, index...index)
                                                    end
                                                    s0 << r26
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Soa0)
          r0.extend(Soa1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:soa][start_index] = r0

        r0
      end

      module ResourceRecord0
        def record
          elements[0]
        end

        def linebreak
          elements[3]
        end
      end

      module ResourceRecord1
        def zone
          p = parent
          while p.respond_to?(:parent) && p.parent
            p = p.parent
          end
          p
        end

        def to_s
          text_value
        end

        def record_type
          record.record_type
        end

        def ttl
          record.ttl || zone.variables['TTL'].to_i
        end

        def method_missing(method_name, *args)
          if record.respond_to?(method_name)
            record.send(method_name, *args)
          end
        end

        def respond_to?(method_name)
          super || record.respond_to?(method_name)
        end

        def parse_type ; :record ; end
      end

      def _nt_resource_record
        start_index = index
        if node_cache[:resource_record].has_key?(index)
          cached = node_cache[:resource_record][index]
          if cached
            node_cache[:resource_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_a_record
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_aaaa_record
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            r4 = _nt_cname_record
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r1 = r4
            else
              r5 = _nt_mx_record
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r1 = r5
              else
                r6 = _nt_naptr_record
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r1 = r6
                else
                  r7 = _nt_ns_record
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r1 = r7
                  else
                    r8 = _nt_ptr_record
                    if r8
                      r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                      r1 = r8
                    else
                      r9 = _nt_srv_record
                      if r9
                        r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                        r1 = r9
                      else
                        r10 = _nt_spf_record
                        if r10
                          r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                          r1 = r10
                        else
                          r11 = _nt_txt_record
                          if r11
                            r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                            r1 = r11
                          else
                            r12 = _nt_soa_record
                            if r12
                              r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                              r1 = r12
                            else
                              @index = i1
                              r1 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        s0 << r1
        if r1
          s13, i13 = [], index
          loop do
            r14 = _nt_space
            if r14
              s13 << r14
            else
              break
            end
          end
          r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
          s0 << r13
          if r13
            r16 = _nt_comment
            if r16
              r15 = r16
            else
              r15 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r15
            if r15
              r17 = _nt_linebreak
              s0 << r17
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ResourceRecord0)
          r0.extend(ResourceRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:resource_record][start_index] = r0

        r0
      end

      module ARecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def ip_address
          elements[7]
        end
      end

      module ARecord1
        def to_s
          "#{host} #{ms_age} #{ttl} #{klass} A #{ip_address}"
        end

        def record_type
          "A"
        end
      end

      def _nt_a_record
        start_index = index
        if node_cache[:a_record].has_key?(index)
          cached = node_cache[:a_record][index]
          if cached
            node_cache[:a_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("A", false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('"A"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_ip_address
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ARecord0)
          r0.extend(ARecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:a_record][start_index] = r0

        r0
      end

      module IpAddress0
      end

      module IpAddress1
        def to_s
          text_value
        end
      end

      def _nt_ip_address
        start_index = index
        if node_cache[:ip_address].has_key?(index)
          cached = node_cache[:ip_address][index]
          if cached
            node_cache[:ip_address][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[\\d]')
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?(".", false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('"."')
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[\\d]')
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s0 << r4
            if r4
              if (match_len = has_terminal?(".", false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('"."')
                r6 = nil
              end
              s0 << r6
              if r6
                s7, i7 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[\\d]')
                    r8 = nil
                  end
                  if r8
                    s7 << r8
                  else
                    break
                  end
                end
                if s7.empty?
                  @index = i7
                  r7 = nil
                else
                  r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                end
                s0 << r7
                if r7
                  if (match_len = has_terminal?(".", false, index))
                    r9 = true
                    @index += match_len
                  else
                    terminal_parse_failure('"."')
                    r9 = nil
                  end
                  s0 << r9
                  if r9
                    s10, i10 = [], index
                    loop do
                      if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
                        r11 = true
                        @index += 1
                      else
                        terminal_parse_failure('[\\d]')
                        r11 = nil
                      end
                      if r11
                        s10 << r11
                      else
                        break
                      end
                    end
                    if s10.empty?
                      @index = i10
                      r10 = nil
                    else
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                    end
                    s0 << r10
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IpAddress0)
          r0.extend(IpAddress1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ip_address][start_index] = r0

        r0
      end

      module AaaaRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def ip_address
          elements[6]
        end
      end

      module AaaaRecord1
        def to_s
          "#{host} #{ttl} #{klass} AAAA #{ip_address}"
        end

        def record_type
          "AAAA"
        end
      end

      def _nt_aaaa_record
        start_index = index
        if node_cache[:aaaa_record].has_key?(index)
          cached = node_cache[:aaaa_record][index]
          if cached
            node_cache[:aaaa_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("AAAA", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"AAAA"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_ip6_address
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AaaaRecord0)
          r0.extend(AaaaRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:aaaa_record][start_index] = r0

        r0
      end

      module Ip6Address0
        def to_s
          text_value.downcase
        end
      end

      def _nt_ip6_address
        start_index = index
        if node_cache[:ip6_address].has_key?(index)
          cached = node_cache[:ip6_address][index]
          if cached
            node_cache[:ip6_address][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\da-fA-F:.]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[\\da-fA-F:.]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
          if s0.size == 39
            break
          end
        end
        if s0.size < 2
          @index = i0
          r0 = nil
        else
          if s0.size < 39
            terminal_failures.pop
          end
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ip6Address0)
        end

        node_cache[:ip6_address][start_index] = r0

        r0
      end

      module CnameRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def target
          elements[6]
        end
      end

      module CnameRecord1
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass
          elements[2]
        end

        def ttl
          elements[3]
        end

        def space2
          elements[5]
        end

        def target
          elements[6]
        end
      end

      module CnameRecord2
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def space2
          elements[4]
        end

        def target
          elements[5]
        end
      end

      module CnameRecord3
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass
          elements[2]
        end

        def space2
          elements[4]
        end

        def target
          elements[5]
        end
      end

      module CnameRecord4
        def to_s
          "#{host} #{ttl} #{klass} CNAME #{target}"
        end

        def record_type
          "CNAME"
        end
      end

      def _nt_cname_record
        start_index = index
        if node_cache[:cname_record].has_key?(index)
          cached = node_cache[:cname_record][index]
          if cached
            node_cache[:cname_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_host
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
          if r3
            r4 = _nt_ttl
            s1 << r4
            if r4
              r5 = _nt_klass
              s1 << r5
              if r5
                if (match_len = has_terminal?("CNAME", false, index))
                  r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"CNAME"')
                  r6 = nil
                end
                s1 << r6
                if r6
                  r7 = _nt_space
                  s1 << r7
                  if r7
                    r8 = _nt_host
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CnameRecord0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(CnameRecord4)
        else
          i9, s9 = index, []
          r10 = _nt_host
          s9 << r10
          if r10
            r11 = _nt_space
            s9 << r11
            if r11
              r12 = _nt_klass
              s9 << r12
              if r12
                r13 = _nt_ttl
                s9 << r13
                if r13
                  if (match_len = has_terminal?("CNAME", false, index))
                    r14 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"CNAME"')
                    r14 = nil
                  end
                  s9 << r14
                  if r14
                    r15 = _nt_space
                    s9 << r15
                    if r15
                      r16 = _nt_host
                      s9 << r16
                    end
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(CnameRecord1)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
            r0.extend(CnameRecord4)
          else
            i17, s17 = index, []
            r18 = _nt_host
            s17 << r18
            if r18
              r19 = _nt_space
              s17 << r19
              if r19
                r20 = _nt_ttl
                s17 << r20
                if r20
                  if (match_len = has_terminal?("CNAME", false, index))
                    r21 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"CNAME"')
                    r21 = nil
                  end
                  s17 << r21
                  if r21
                    r22 = _nt_space
                    s17 << r22
                    if r22
                      r23 = _nt_host
                      s17 << r23
                    end
                  end
                end
              end
            end
            if s17.last
              r17 = instantiate_node(SyntaxNode,input, i17...index, s17)
              r17.extend(CnameRecord2)
            else
              @index = i17
              r17 = nil
            end
            if r17
              r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
              r0 = r17
              r0.extend(CnameRecord4)
            else
              i24, s24 = index, []
              r25 = _nt_host
              s24 << r25
              if r25
                r26 = _nt_space
                s24 << r26
                if r26
                  r27 = _nt_klass
                  s24 << r27
                  if r27
                    if (match_len = has_terminal?("CNAME", false, index))
                      r28 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('"CNAME"')
                      r28 = nil
                    end
                    s24 << r28
                    if r28
                      r29 = _nt_space
                      s24 << r29
                      if r29
                        r30 = _nt_host
                        s24 << r30
                      end
                    end
                  end
                end
              end
              if s24.last
                r24 = instantiate_node(SyntaxNode,input, i24...index, s24)
                r24.extend(CnameRecord3)
              else
                @index = i24
                r24 = nil
              end
              if r24
                r24 = SyntaxNode.new(input, (index-1)...index) if r24 == true
                r0 = r24
                r0.extend(CnameRecord4)
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:cname_record][start_index] = r0

        r0
      end

      module MxRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def priority
          elements[6]
        end

        def space3
          elements[7]
        end

        def exchanger
          elements[8]
        end
      end

      module MxRecord1
        def to_s
          "#{host} #{ttl} #{klass} MX #{priority} #{exchanger}"
        end

        def record_type
          "MX"
        end
      end

      def _nt_mx_record
        start_index = index
        if node_cache[:mx_record].has_key?(index)
          cached = node_cache[:mx_record][index]
          if cached
            node_cache[:mx_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("MX", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"MX"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_integer
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                      if r8
                        r9 = _nt_host
                        s0 << r9
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MxRecord0)
          r0.extend(MxRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:mx_record][start_index] = r0

        r0
      end

      module NaptrRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def data
          elements[6]
        end
      end

      module NaptrRecord1
        def to_s
          "#{host} #{ttl} #{klass} NAPTR #{data}"
        end

        def record_type
          "NAPTR"
        end
      end

      def _nt_naptr_record
        start_index = index
        if node_cache[:naptr_record].has_key?(index)
          cached = node_cache[:naptr_record][index]
          if cached
            node_cache[:naptr_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("NAPTR", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"NAPTR"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_data
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NaptrRecord0)
          r0.extend(NaptrRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:naptr_record][start_index] = r0

        r0
      end

      module NsRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def nameserver
          elements[6]
        end
      end

      module NsRecord1
        def to_s
          "#{host} #{ttl} #{klass} NS #{nameserver}"
        end

        def record_type
          "NS"
        end
      end

      def _nt_ns_record
        start_index = index
        if node_cache[:ns_record].has_key?(index)
          cached = node_cache[:ns_record][index]
          if cached
            node_cache[:ns_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("NS", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"NS"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_host
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NsRecord0)
          r0.extend(NsRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ns_record][start_index] = r0

        r0
      end

      module PtrRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def target
          elements[6]
        end
      end

      module PtrRecord1
        def to_s
          "#{host} #{ttl} #{klass} PTR #{target}"
        end

        def record_type
          "PTR"
        end
      end

      def _nt_ptr_record
        start_index = index
        if node_cache[:ptr_record].has_key?(index)
          cached = node_cache[:ptr_record][index]
          if cached
            node_cache[:ptr_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("PTR", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"PTR"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_host
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PtrRecord0)
          r0.extend(PtrRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ptr_record][start_index] = r0

        r0
      end

      module SoaRecord0
        def origin
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def ns
          elements[6]
        end

        def space3
          elements[7]
        end

        def rp
          elements[8]
        end

        def space4
          elements[9]
        end

        def data
          elements[10]
        end
      end

      module SoaRecord1
        def to_s
          "#{origin} #{ttl} #{klass} SOA #{ns} #{rp} (#{space})"
        end

        def record_type
          "SOA"
        end
      end

      def _nt_soa_record
        start_index = index
        if node_cache[:soa_record].has_key?(index)
          cached = node_cache[:soa_record][index]
          if cached
            node_cache[:soa_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_origin
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("SOA", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"SOA"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_ns
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                      if r8
                        r9 = _nt_rp
                        s0 << r9
                        if r9
                          r10 = _nt_space
                          s0 << r10
                          if r10
                            r11 = _nt_data
                            s0 << r11
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SoaRecord0)
          r0.extend(SoaRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:soa_record][start_index] = r0

        r0
      end

      module SrvRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def priority
          elements[6]
        end

        def space3
          elements[7]
        end

        def weight
          elements[8]
        end

        def space4
          elements[9]
        end

        def port
          elements[10]
        end

        def space5
          elements[11]
        end

        def target
          elements[12]
        end
      end

      module SrvRecord1
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass
          elements[2]
        end

        def ttl
          elements[3]
        end

        def space2
          elements[5]
        end

        def priority
          elements[6]
        end

        def space3
          elements[7]
        end

        def weight
          elements[8]
        end

        def space4
          elements[9]
        end

        def port
          elements[10]
        end

        def space5
          elements[11]
        end

        def target
          elements[12]
        end
      end

      module SrvRecord2
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def space2
          elements[4]
        end

        def priority
          elements[5]
        end

        def space3
          elements[6]
        end

        def weight
          elements[7]
        end

        def space4
          elements[8]
        end

        def port
          elements[9]
        end

        def space5
          elements[10]
        end

        def target
          elements[11]
        end
      end

      module SrvRecord3
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass
          elements[2]
        end

        def space2
          elements[4]
        end

        def priority
          elements[5]
        end

        def space3
          elements[6]
        end

        def weight
          elements[7]
        end

        def space4
          elements[8]
        end

        def port
          elements[9]
        end

        def space5
          elements[10]
        end

        def target
          elements[11]
        end
      end

      module SrvRecord4
        def to_s
          "#{host} #{ttl} #{klass} SRV #{priority} #{weight} #{port} #{target}"
        end

        def record_type
          "SRV"
        end
      end

      def _nt_srv_record
        start_index = index
        if node_cache[:srv_record].has_key?(index)
          cached = node_cache[:srv_record][index]
          if cached
            node_cache[:srv_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_host
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
          if r3
            r4 = _nt_ttl
            s1 << r4
            if r4
              r5 = _nt_klass
              s1 << r5
              if r5
                if (match_len = has_terminal?("SRV", false, index))
                  r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"SRV"')
                  r6 = nil
                end
                s1 << r6
                if r6
                  r7 = _nt_space
                  s1 << r7
                  if r7
                    r8 = _nt_integer
                    s1 << r8
                    if r8
                      r9 = _nt_space
                      s1 << r9
                      if r9
                        r10 = _nt_integer
                        s1 << r10
                        if r10
                          r11 = _nt_space
                          s1 << r11
                          if r11
                            r12 = _nt_integer
                            s1 << r12
                            if r12
                              r13 = _nt_space
                              s1 << r13
                              if r13
                                r14 = _nt_host
                                s1 << r14
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(SrvRecord0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(SrvRecord4)
        else
          i15, s15 = index, []
          r16 = _nt_host
          s15 << r16
          if r16
            r17 = _nt_space
            s15 << r17
            if r17
              r18 = _nt_klass
              s15 << r18
              if r18
                r19 = _nt_ttl
                s15 << r19
                if r19
                  if (match_len = has_terminal?("SRV", false, index))
                    r20 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"SRV"')
                    r20 = nil
                  end
                  s15 << r20
                  if r20
                    r21 = _nt_space
                    s15 << r21
                    if r21
                      r22 = _nt_integer
                      s15 << r22
                      if r22
                        r23 = _nt_space
                        s15 << r23
                        if r23
                          r24 = _nt_integer
                          s15 << r24
                          if r24
                            r25 = _nt_space
                            s15 << r25
                            if r25
                              r26 = _nt_integer
                              s15 << r26
                              if r26
                                r27 = _nt_space
                                s15 << r27
                                if r27
                                  r28 = _nt_host
                                  s15 << r28
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if s15.last
            r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
            r15.extend(SrvRecord1)
          else
            @index = i15
            r15 = nil
          end
          if r15
            r15 = SyntaxNode.new(input, (index-1)...index) if r15 == true
            r0 = r15
            r0.extend(SrvRecord4)
          else
            i29, s29 = index, []
            r30 = _nt_host
            s29 << r30
            if r30
              r31 = _nt_space
              s29 << r31
              if r31
                r32 = _nt_ttl
                s29 << r32
                if r32
                  if (match_len = has_terminal?("SRV", false, index))
                    r33 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"SRV"')
                    r33 = nil
                  end
                  s29 << r33
                  if r33
                    r34 = _nt_space
                    s29 << r34
                    if r34
                      r35 = _nt_integer
                      s29 << r35
                      if r35
                        r36 = _nt_space
                        s29 << r36
                        if r36
                          r37 = _nt_integer
                          s29 << r37
                          if r37
                            r38 = _nt_space
                            s29 << r38
                            if r38
                              r39 = _nt_integer
                              s29 << r39
                              if r39
                                r40 = _nt_space
                                s29 << r40
                                if r40
                                  r41 = _nt_host
                                  s29 << r41
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
            if s29.last
              r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
              r29.extend(SrvRecord2)
            else
              @index = i29
              r29 = nil
            end
            if r29
              r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
              r0 = r29
              r0.extend(SrvRecord4)
            else
              i42, s42 = index, []
              r43 = _nt_host
              s42 << r43
              if r43
                r44 = _nt_space
                s42 << r44
                if r44
                  r45 = _nt_klass
                  s42 << r45
                  if r45
                    if (match_len = has_terminal?("SRV", false, index))
                      r46 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('"SRV"')
                      r46 = nil
                    end
                    s42 << r46
                    if r46
                      r47 = _nt_space
                      s42 << r47
                      if r47
                        r48 = _nt_integer
                        s42 << r48
                        if r48
                          r49 = _nt_space
                          s42 << r49
                          if r49
                            r50 = _nt_integer
                            s42 << r50
                            if r50
                              r51 = _nt_space
                              s42 << r51
                              if r51
                                r52 = _nt_integer
                                s42 << r52
                                if r52
                                  r53 = _nt_space
                                  s42 << r53
                                  if r53
                                    r54 = _nt_host
                                    s42 << r54
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
              if s42.last
                r42 = instantiate_node(SyntaxNode,input, i42...index, s42)
                r42.extend(SrvRecord3)
              else
                @index = i42
                r42 = nil
              end
              if r42
                r42 = SyntaxNode.new(input, (index-1)...index) if r42 == true
                r0 = r42
                r0.extend(SrvRecord4)
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:srv_record][start_index] = r0

        r0
      end

      module SpfRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def data
          elements[6]
        end
      end

      module SpfRecord1
        def to_s
          "#{host} #{ttl} #{klass} SPF #{data}"
        end

        def record_type
          "SPF"
        end
      end

      def _nt_spf_record
        start_index = index
        if node_cache[:spf_record].has_key?(index)
          cached = node_cache[:spf_record][index]
          if cached
            node_cache[:spf_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("SPF", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"SPF"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_txt_data
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SpfRecord0)
          r0.extend(SpfRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:spf_record][start_index] = r0

        r0
      end

      module TxtRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def data
          elements[6]
        end
      end

      module TxtRecord1
        def to_s
          "#{host} #{ttl} #{klass} TXT #{data}"
        end

        def record_type
          "TXT"
        end
      end

      def _nt_txt_record
        start_index = index
        if node_cache[:txt_record].has_key?(index)
          cached = node_cache[:txt_record][index]
          if cached
            node_cache[:txt_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("TXT", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"TXT"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_ms_txt_data
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TxtRecord0)
          r0.extend(TxtRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:txt_record][start_index] = r0

        r0
      end

      module Origin0
        def host
          elements[0]
        end

      end

      module Origin1
        def to_s
          "#{host}"
        end
      end

      def _nt_origin
        start_index = index
        if node_cache[:origin].has_key?(index)
          cached = node_cache[:origin][index]
          if cached
            node_cache[:origin][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Origin0)
          r0.extend(Origin1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:origin][start_index] = r0

        r0
      end

      module Space0
        def to_s
          text_value
        end
      end

      def _nt_space
        start_index = index
        if node_cache[:space].has_key?(index)
          cached = node_cache[:space][index]
          if cached
            node_cache[:space][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[ \\t]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[ \\t]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Space0)
        end

        node_cache[:space][start_index] = r0

        r0
      end

      module Linebreak0
        def to_s
          ''
        end
      end

      def _nt_linebreak
        start_index = index
        if node_cache[:linebreak].has_key?(index)
          cached = node_cache[:linebreak][index]
          if cached
            node_cache[:linebreak][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\n\\r]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[\\n\\r]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Linebreak0)
        end

        node_cache[:linebreak][start_index] = r0

        r0
      end

      module SpaceOrBreak0
        def to_s
          text_value
        end
      end

      def _nt_space_or_break
        start_index = index
        if node_cache[:space_or_break].has_key?(index)
          cached = node_cache[:space_or_break][index]
          if cached
            node_cache[:space_or_break][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\s]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[\\s]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SpaceOrBreak0)
        end

        node_cache[:space_or_break][start_index] = r0

        r0
      end

      module Klass0
        def space
          elements[1]
        end
      end

      module Klass1
        def to_s
          text_value.strip
        end
      end

      def _nt_klass
        start_index = index
        if node_cache[:klass].has_key?(index)
          cached = node_cache[:klass][index]
          if cached
            node_cache[:klass][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?("IN", false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"IN"')
          r2 = nil
        end
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Klass0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(Klass1)
        else
          if (match_len = has_terminal?('', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('\'\'')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
            r0.extend(Klass1)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:klass][start_index] = r0

        r0
      end

      module Comment0
      end

      module Comment1
        def to_s
          text_value.strip
        end
      end

      def _nt_comment
        start_index = index
        if node_cache[:comment].has_key?(index)
          cached = node_cache[:comment][index]
          if cached
            node_cache[:comment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          r2 = _nt_space
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          if (match_len = has_terminal?(";", false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('";"')
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[^\\n\\r]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[^\\n\\r]')
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Comment0)
          r0.extend(Comment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:comment][start_index] = r0

        r0
      end

      module Ns0
        def host
          elements[0]
        end

      end

      module Ns1
        def to_s
          "#{host}"
        end
      end

      def _nt_ns
        start_index = index
        if node_cache[:ns].has_key?(index)
          cached = node_cache[:ns][index]
          if cached
            node_cache[:ns][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ns0)
          r0.extend(Ns1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ns][start_index] = r0

        r0
      end

      module Rp0
      end

      module Rp1
        def to_s
          text_value
        end
      end

      def _nt_rp
        start_index = index
        if node_cache[:rp].has_key?(index)
          cached = node_cache[:rp][index]
          if cached
            node_cache[:rp][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1, s1 = index, []
          s2, i2 = [], index
          loop do
            i3 = index
            if (match_len = has_terminal?("\\.", false, index))
              r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('"\\\\."')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              if has_terminal?(@regexps[gr = '\A[+a-zA-Z0-9\\-)]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[+a-zA-Z0-9\\-)]')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s1 << r2
          if r2
            if (match_len = has_terminal?(".", false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('"."')
              r6 = nil
            end
            s1 << r6
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(Rp0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Rp1)
        end

        node_cache[:rp][start_index] = r0

        r0
      end

      module Serial0
        def integer
          elements[0]
        end

      end

      module Serial1
        def to_i
          integer.to_i
        end
        def to_s
          "#{to_i}"
        end
      end

      def _nt_serial
        start_index = index
        if node_cache[:serial].has_key?(index)
          cached = node_cache[:serial][index]
          if cached
            node_cache[:serial][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Serial0)
          r0.extend(Serial1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:serial][start_index] = r0

        r0
      end

      module TimeInterval0
        def integer
          elements[0]
        end

        def time_multiplier
          elements[1]
        end
      end

      module TimeInterval1
        def to_s
          text_value
        end

        def to_i
          time_multiplier.to_i * integer.to_i
        end
      end

      def _nt_time_interval
        start_index = index
        if node_cache[:time_interval].has_key?(index)
          cached = node_cache[:time_interval][index]
          if cached
            node_cache[:time_interval][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer
        s0 << r1
        if r1
          r2 = _nt_time_multiplier
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TimeInterval0)
          r0.extend(TimeInterval1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:time_interval][start_index] = r0

        r0
      end

      module Refresh0
        def time_interval
          elements[0]
        end

      end

      module Refresh1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_refresh
        start_index = index
        if node_cache[:refresh].has_key?(index)
          cached = node_cache[:refresh][index]
          if cached
            node_cache[:refresh][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Refresh0)
          r0.extend(Refresh1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:refresh][start_index] = r0

        r0
      end

      module Integer0
        def to_i
          text_value.to_i
        end
        def to_s
          "#{to_i}"
        end
      end

      def _nt_integer
        start_index = index
        if node_cache[:integer].has_key?(index)
          cached = node_cache[:integer][index]
          if cached
            node_cache[:integer][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Integer0)
        end

        node_cache[:integer][start_index] = r0

        r0
      end

      module TimeMultiplier0
        def to_s
          text_value
        end
        def to_i
          case text_value.downcase
            when 'm' then 60
            when 'h' then 60 * 60
            when 'd' then 60 * 60 * 24
            when 'w' then 60 * 60 * 24 * 7
            else
              1
          end
        end
      end

      def _nt_time_multiplier
        start_index = index
        if node_cache[:time_multiplier].has_key?(index)
          cached = node_cache[:time_multiplier][index]
          if cached
            node_cache[:time_multiplier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('s', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'s\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(TimeMultiplier0)
        else
          if (match_len = has_terminal?('S', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('\'S\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
            r0.extend(TimeMultiplier0)
          else
            if (match_len = has_terminal?('m', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'m\'')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
              r0.extend(TimeMultiplier0)
            else
              if (match_len = has_terminal?('M', false, index))
                r4 = true
                @index += match_len
              else
                terminal_parse_failure('\'M\'')
                r4 = nil
              end
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
                r0.extend(TimeMultiplier0)
              else
                if (match_len = has_terminal?('h', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'h\'')
                  r5 = nil
                end
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                  r0.extend(TimeMultiplier0)
                else
                  if (match_len = has_terminal?('H', false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'H\'')
                    r6 = nil
                  end
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                    r0.extend(TimeMultiplier0)
                  else
                    if (match_len = has_terminal?('d', false, index))
                      r7 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\'d\'')
                      r7 = nil
                    end
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                      r0.extend(TimeMultiplier0)
                    else
                      if (match_len = has_terminal?('D', false, index))
                        r8 = true
                        @index += match_len
                      else
                        terminal_parse_failure('\'D\'')
                        r8 = nil
                      end
                      if r8
                        r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                        r0 = r8
                        r0.extend(TimeMultiplier0)
                      else
                        if (match_len = has_terminal?('w', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'w\'')
                          r9 = nil
                        end
                        if r9
                          r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                          r0 = r9
                          r0.extend(TimeMultiplier0)
                        else
                          if (match_len = has_terminal?('W', false, index))
                            r10 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'W\'')
                            r10 = nil
                          end
                          if r10
                            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                            r0 = r10
                            r0.extend(TimeMultiplier0)
                          else
                            if (match_len = has_terminal?('', false, index))
                              r11 = true
                              @index += match_len
                            else
                              terminal_parse_failure('\'\'')
                              r11 = nil
                            end
                            if r11
                              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                              r0 = r11
                              r0.extend(TimeMultiplier0)
                            else
                              @index = i0
                              r0 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:time_multiplier][start_index] = r0

        r0
      end

      module Reretry0
        def time_interval
          elements[0]
        end

      end

      module Reretry1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_reretry
        start_index = index
        if node_cache[:reretry].has_key?(index)
          cached = node_cache[:reretry][index]
          if cached
            node_cache[:reretry][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Reretry0)
          r0.extend(Reretry1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:reretry][start_index] = r0

        r0
      end

      module Expiry0
        def time_interval
          elements[0]
        end

      end

      module Expiry1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_expiry
        start_index = index
        if node_cache[:expiry].has_key?(index)
          cached = node_cache[:expiry][index]
          if cached
            node_cache[:expiry][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Expiry0)
          r0.extend(Expiry1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:expiry][start_index] = r0

        r0
      end

      module Nxttl0
        def time_interval
          elements[0]
        end

      end

      module Nxttl1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_nxttl
        start_index = index
        if node_cache[:nxttl].has_key?(index)
          cached = node_cache[:nxttl][index]
          if cached
            node_cache[:nxttl][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Nxttl0)
          r0.extend(Nxttl1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:nxttl][start_index] = r0

        r0
      end

      module MsAge0
        def space
          elements[3]
        end
      end

      module MsAge1
        def to_s
          text_value
        end
      end

      def _nt_ms_age
        start_index = index
        if node_cache[:ms_age].has_key?(index)
          cached = node_cache[:ms_age][index]
          if cached
            node_cache[:ms_age][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?("[AGE:", false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"[AGE:"')
          r2 = nil
        end
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[\\d]')
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
          if r3
            if (match_len = has_terminal?("]", false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('"]"')
              r5 = nil
            end
            s1 << r5
            if r5
              r6 = _nt_space
              s1 << r6
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(MsAge0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(MsAge1)
        else
          if (match_len = has_terminal?('', false, index))
            r7 = true
            @index += match_len
          else
            terminal_parse_failure('\'\'')
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
            r0.extend(MsAge1)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:ms_age][start_index] = r0

        r0
      end

      module Ttl0
        def time_interval
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module Ttl1
        def to_i
          respond_to?(:time_interval) ? time_interval.to_i : nil
        end
        def to_s
          respond_to?(:time_interval) ? time_interval.to_s : ''
        end
      end

      def _nt_ttl
        start_index = index
        if node_cache[:ttl].has_key?(index)
          cached = node_cache[:ttl][index]
          if cached
            node_cache[:ttl][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_time_interval
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Ttl0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(Ttl1)
        else
          if (match_len = has_terminal?('', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('\'\'')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
            r0.extend(Ttl1)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:ttl][start_index] = r0

        r0
      end

      module Host0
        def to_s
          case text_value
          when /\.$/
            text_value
          when "@", /\s/
            text_value
          else
            text_value + '.@'
          end
        end
      end

      def _nt_host
        start_index = index
        if node_cache[:host].has_key?(index)
          cached = node_cache[:host][index]
          if cached
            node_cache[:host][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        s1, i1 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[*a-zA-Z0-9\\-\\._]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[*a-zA-Z0-9\\-\\._]')
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(Host0)
        else
          if (match_len = has_terminal?("@", false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('"@"')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r0 = r3
            r0.extend(Host0)
          else
            if (match_len = has_terminal?(' ', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\' \'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r0 = r4
              r0.extend(Host0)
            else
              if (match_len = has_terminal?("\t", false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('"\\t"')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r0 = r5
                r0.extend(Host0)
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:host][start_index] = r0

        r0
      end

      module Data0
        def to_s
          text_value.strip
        end
      end

      def _nt_data
        start_index = index
        if node_cache[:data].has_key?(index)
          cached = node_cache[:data][index]
          if cached
            node_cache[:data][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[^;\\n\\r]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[^;\\n\\r]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Data0)
        end

        node_cache[:data][start_index] = r0

        r0
      end

      module MsTxtData0
        def data
          elements[2]
        end

      end

      module MsTxtData1
        def data
          elements[0]
        end
      end

      module MsTxtData2
        def to_s
          data.to_s
        end
      end

      def _nt_ms_txt_data
        start_index = index
        if node_cache[:ms_txt_data].has_key?(index)
          cached = node_cache[:ms_txt_data][index]
          if cached
            node_cache[:ms_txt_data][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?("(", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"("')
          r2 = nil
        end
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            r4 = _nt_space
            if r4
              s3 << r4
            else
              break
            end
          end
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          s1 << r3
          if r3
            r5 = _nt_txt_data
            s1 << r5
            if r5
              s6, i6 = [], index
              loop do
                r7 = _nt_space
                if r7
                  s6 << r7
                else
                  break
                end
              end
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              s1 << r6
              if r6
                if (match_len = has_terminal?(")", false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('")"')
                  r8 = nil
                end
                s1 << r8
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(MsTxtData0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(MsTxtData2)
        else
          i9, s9 = index, []
          r10 = _nt_txt_data
          s9 << r10
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(MsTxtData1)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
            r0.extend(MsTxtData2)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:ms_txt_data][start_index] = r0

        r0
      end

      module TxtData0
        def space
          elements[0]
        end

        def txt_data
          elements[1]
        end
      end

      module TxtData1
        def txt_string
          elements[0]
        end

      end

      module TxtData2
        def to_s
          text_value
        end
      end

      def _nt_txt_data
        start_index = index
        if node_cache[:txt_data].has_key?(index)
          cached = node_cache[:txt_data][index]
          if cached
            node_cache[:txt_data][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_txt_string
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_space
            s3 << r4
            if r4
              r5 = _nt_txt_data
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(TxtData0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TxtData1)
          r0.extend(TxtData2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:txt_data][start_index] = r0

        r0
      end

      module TxtString0
        def to_s
          text_value
        end
      end

      def _nt_txt_string
        start_index = index
        if node_cache[:txt_string].has_key?(index)
          cached = node_cache[:txt_string][index]
          if cached
            node_cache[:txt_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_quoted_string
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(TxtString0)
        else
          r2 = _nt_unquoted_string
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
            r0.extend(TxtString0)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:txt_string][start_index] = r0

        r0
      end

      module QuotedString0
      end

      module QuotedString1
        def to_s
          text_value
        end
      end

      def _nt_quoted_string
        start_index = index
        if node_cache[:quoted_string].has_key?(index)
          cached = node_cache[:quoted_string][index]
          if cached
            node_cache[:quoted_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('"', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'"\'')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3 = index
            if (match_len = has_terminal?('\"', false, index))
              r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'\\"\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              if has_terminal?(@regexps[gr = '\A[^"]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[^"]')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?('"', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('\'"\'')
              r6 = nil
            end
            s0 << r6
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(QuotedString0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:quoted_string][start_index] = r0

        r0
      end

      module UnquotedString0
        def to_s
          text_value
        end
      end

      def _nt_unquoted_string
        start_index = index
        if node_cache[:unquoted_string].has_key?(index)
          cached = node_cache[:unquoted_string][index]
          if cached
            node_cache[:unquoted_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[a-zA-Z0-9]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UnquotedString0)
        end

        node_cache[:unquoted_string][start_index] = r0

        r0
      end

    end

    class Parser < Treetop::Runtime::CompiledParser
      include ZonefileGrammar # :nodoc:
    end
  end
end