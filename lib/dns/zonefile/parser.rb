require 'treetop'

module DNS
  module Zonefile
    # Autogenerated from a Treetop grammar. Edits may be lost.


    module ZonefileGrammar # :nodoc:
      include Treetop::Runtime

      def root
        @root ||= :zone
      end

      module Zone0
        def soa
          elements[1]
        end

      end

      module Zone1
        def variables
          @variables ||= begin
            raw = elements[0].elements.select { |e| e.to_s =~ /^\$/ }
            variables = {}
            raw.each do |e|
              variables[e.name.text_value.to_s] = e.value.text_value.to_s
            end
            variables
          end
        end

        def origin
          soa.origin.host.to_s
        end

        def to_s
          text_value
        end

        def rr
          elements[-1].elements.select { |e| e.to_s !~ /\A\s*([;$].*)?\z|\A\z/; }
        end

        def entries
          elements[0].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; } +
            [soa] +
            elements[-1].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; }
        end
      end

      def _nt_zone
        start_index = index
        if node_cache[:zone].has_key?(index)
          cached = node_cache[:zone][index]
          if cached
            node_cache[:zone][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          i2 = index
          r3 = _nt_variable
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r2 = r3
          else
            r4 = _nt_space_or_break
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r2 = r4
            else
              r5 = _nt_comment
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r2 = r5
              else
                @index = i2
                r2 = nil
              end
            end
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          r6 = _nt_soa
          s0 << r6
          if r6
            s7, i7 = [], index
            loop do
              i8 = index
              r9 = _nt_resource_record
              if r9
                r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                r8 = r9
              else
                r10 = _nt_variable
                if r10
                  r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                  r8 = r10
                else
                  r11 = _nt_comment
                  if r11
                    r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                    r8 = r11
                  else
                    r12 = _nt_space
                    if r12
                      r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                      r8 = r12
                    else
                      r13 = _nt_linebreak
                      if r13
                        r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                        r8 = r13
                      else
                        @index = i8
                        r8 = nil
                      end
                    end
                  end
                end
              end
              if r8
                s7 << r8
              else
                break
              end
            end
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            s0 << r7
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Zone0)
          r0.extend(Zone1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:zone][start_index] = r0

        r0
      end

      module Variable0
        def name
          elements[1]
        end

        def space
          elements[2]
        end

        def value
          elements[3]
        end

      end

      module Variable1
        def to_s
          "$#{name.text_value.to_s} #{value.text_value.to_s}"
        end

        def parse_type ; :variable ; end
      end

      def _nt_variable
        start_index = index
        if node_cache[:variable].has_key?(index)
          cached = node_cache[:variable][index]
          if cached
            node_cache[:variable][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("$", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"$"')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[a-zA-Z0-9]')
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
          if r2
            r4 = _nt_space
            s0 << r4
            if r4
              s5, i5 = [], index
              loop do
                if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9\\.\\-]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[a-zA-Z0-9\\.\\-]')
                  r6 = nil
                end
                if r6
                  s5 << r6
                else
                  break
                end
              end
              if s5.empty?
                @index = i5
                r5 = nil
              else
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              end
              s0 << r5
              if r5
                r8 = _nt_space
                if r8
                  r7 = r8
                else
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r7
                if r7
                  r10 = _nt_comment
                  if r10
                    r9 = r10
                  else
                    r9 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r9
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Variable0)
          r0.extend(Variable1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:variable][start_index] = r0

        r0
      end

      module Soa0
        def origin
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def ns
          elements[6]
        end

        def space3
          elements[7]
        end

        def rp
          elements[8]
        end

        def space4
          elements[9]
        end

        def serial
          elements[13]
        end

        def space_or_break1
          elements[15]
        end

        def refresh
          elements[16]
        end

        def space_or_break2
          elements[18]
        end

        def reretry
          elements[19]
        end

        def space_or_break3
          elements[21]
        end

        def expiry
          elements[22]
        end

        def space_or_break4
          elements[24]
        end

        def nxttl
          elements[25]
        end

      end

      module Soa1
        def to_s
          "#{origin} #{ttl} #{klass} SOA #{ns} #{rp} (#{serial} #{refresh} #{reretry} #{expiry} #{nxttl})"
        end

        def parse_type ; :soa ; end
      end

      def _nt_soa
        start_index = index
        if node_cache[:soa].has_key?(index)
          cached = node_cache[:soa][index]
          if cached
            node_cache[:soa][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_origin
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("SOA", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"SOA"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_ns
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                      if r8
                        r9 = _nt_rp
                        s0 << r9
                        if r9
                          r10 = _nt_space
                          s0 << r10
                          if r10
                            if (match_len = has_terminal?("(", false, index))
                              r12 = true
                              @index += match_len
                            else
                              terminal_parse_failure('"("')
                              r12 = nil
                            end
                            if r12
                              r11 = r12
                            else
                              r11 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s0 << r11
                            if r11
                              s13, i13 = [], index
                              loop do
                                r14 = _nt_multiline_comment
                                if r14
                                  s13 << r14
                                else
                                  break
                                end
                              end
                              r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                              s0 << r13
                              if r13
                                s15, i15 = [], index
                                loop do
                                  r16 = _nt_space_or_break
                                  if r16
                                    s15 << r16
                                  else
                                    break
                                  end
                                end
                                r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
                                s0 << r15
                                if r15
                                  r17 = _nt_serial
                                  s0 << r17
                                  if r17
                                    s18, i18 = [], index
                                    loop do
                                      r19 = _nt_multiline_comment
                                      if r19
                                        s18 << r19
                                      else
                                        break
                                      end
                                    end
                                    r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
                                    s0 << r18
                                    if r18
                                      r20 = _nt_space_or_break
                                      s0 << r20
                                      if r20
                                        r21 = _nt_refresh
                                        s0 << r21
                                        if r21
                                          s22, i22 = [], index
                                          loop do
                                            r23 = _nt_multiline_comment
                                            if r23
                                              s22 << r23
                                            else
                                              break
                                            end
                                          end
                                          r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                                          s0 << r22
                                          if r22
                                            r24 = _nt_space_or_break
                                            s0 << r24
                                            if r24
                                              r25 = _nt_reretry
                                              s0 << r25
                                              if r25
                                                s26, i26 = [], index
                                                loop do
                                                  r27 = _nt_multiline_comment
                                                  if r27
                                                    s26 << r27
                                                  else
                                                    break
                                                  end
                                                end
                                                r26 = instantiate_node(SyntaxNode,input, i26...index, s26)
                                                s0 << r26
                                                if r26
                                                  r28 = _nt_space_or_break
                                                  s0 << r28
                                                  if r28
                                                    r29 = _nt_expiry
                                                    s0 << r29
                                                    if r29
                                                      s30, i30 = [], index
                                                      loop do
                                                        r31 = _nt_multiline_comment
                                                        if r31
                                                          s30 << r31
                                                        else
                                                          break
                                                        end
                                                      end
                                                      r30 = instantiate_node(SyntaxNode,input, i30...index, s30)
                                                      s0 << r30
                                                      if r30
                                                        r32 = _nt_space_or_break
                                                        s0 << r32
                                                        if r32
                                                          r33 = _nt_nxttl
                                                          s0 << r33
                                                          if r33
                                                            s34, i34 = [], index
                                                            loop do
                                                              r35 = _nt_multiline_comment
                                                              if r35
                                                                s34 << r35
                                                              else
                                                                break
                                                              end
                                                            end
                                                            r34 = instantiate_node(SyntaxNode,input, i34...index, s34)
                                                            s0 << r34
                                                            if r34
                                                              s36, i36 = [], index
                                                              loop do
                                                                r37 = _nt_space_or_break
                                                                if r37
                                                                  s36 << r37
                                                                else
                                                                  break
                                                                end
                                                              end
                                                              r36 = instantiate_node(SyntaxNode,input, i36...index, s36)
                                                              s0 << r36
                                                              if r36
                                                                if (match_len = has_terminal?(")", false, index))
                                                                  r39 = true
                                                                  @index += match_len
                                                                else
                                                                  terminal_parse_failure('")"')
                                                                  r39 = nil
                                                                end
                                                                if r39
                                                                  r38 = r39
                                                                else
                                                                  r38 = instantiate_node(SyntaxNode,input, index...index)
                                                                end
                                                                s0 << r38
                                                              end
                                                            end
                                                          end
                                                        end
                                                      end
                                                    end
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Soa0)
          r0.extend(Soa1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:soa][start_index] = r0

        r0
      end

      module ResourceRecord0
        def record
          elements[0]
        end

        def linebreak
          elements[3]
        end
      end

      module ResourceRecord1
        def zone
          p = parent
          while p.respond_to?(:parent) && p.parent
            p = p.parent
          end
          p
        end

        def to_s
          text_value
        end

        def record_type
          record.record_type
        end

        def ttl
          record.ttl || zone.variables['TTL'].to_i
        end

        def method_missing(method_name, *args)
          if record.respond_to?(method_name)
            record.send(method_name, *args)
          end
        end

        def respond_to?(method_name)
          super || record.respond_to?(method_name)
        end

        def parse_type ; :record ; end
      end

      def _nt_resource_record
        start_index = index
        if node_cache[:resource_record].has_key?(index)
          cached = node_cache[:resource_record][index]
          if cached
            node_cache[:resource_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_a_record
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_aaaa_record
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            r4 = _nt_cname_record
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r1 = r4
            else
              r5 = _nt_mx_record
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r1 = r5
              else
                r6 = _nt_naptr_record
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r1 = r6
                else
                  r7 = _nt_ns_record
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r1 = r7
                  else
                    r8 = _nt_ptr_record
                    if r8
                      r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                      r1 = r8
                    else
                      r9 = _nt_srv_record
                      if r9
                        r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                        r1 = r9
                      else
                        r10 = _nt_spf_record
                        if r10
                          r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                          r1 = r10
                        else
                          r11 = _nt_txt_record
                          if r11
                            r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                            r1 = r11
                          else
                            r12 = _nt_soa_record
                            if r12
                              r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                              r1 = r12
                            else
                              @index = i1
                              r1 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        s0 << r1
        if r1
          s13, i13 = [], index
          loop do
            r14 = _nt_space
            if r14
              s13 << r14
            else
              break
            end
          end
          r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
          s0 << r13
          if r13
            r16 = _nt_comment
            if r16
              r15 = r16
            else
              r15 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r15
            if r15
              r17 = _nt_linebreak
              s0 << r17
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ResourceRecord0)
          r0.extend(ResourceRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:resource_record][start_index] = r0

        r0
      end

      module ARecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def ip_address
          elements[7]
        end
      end

      module ARecord1
        def to_s
          "#{host} #{ms_age} #{ttl} #{klass} A #{ip_address}"
        end

        def record_type
          "A"
        end
      end

      def _nt_a_record
        start_index = index
        if node_cache[:a_record].has_key?(index)
          cached = node_cache[:a_record][index]
          if cached
            node_cache[:a_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("A", false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('"A"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_ip_address
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ARecord0)
          r0.extend(ARecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:a_record][start_index] = r0

        r0
      end

      module IpAddress0
      end

      module IpAddress1
        def to_s
          text_value
        end
      end

      def _nt_ip_address
        start_index = index
        if node_cache[:ip_address].has_key?(index)
          cached = node_cache[:ip_address][index]
          if cached
            node_cache[:ip_address][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[\\d]')
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?(".", false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('"."')
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[\\d]')
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s0 << r4
            if r4
              if (match_len = has_terminal?(".", false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('"."')
                r6 = nil
              end
              s0 << r6
              if r6
                s7, i7 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[\\d]')
                    r8 = nil
                  end
                  if r8
                    s7 << r8
                  else
                    break
                  end
                end
                if s7.empty?
                  @index = i7
                  r7 = nil
                else
                  r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                end
                s0 << r7
                if r7
                  if (match_len = has_terminal?(".", false, index))
                    r9 = true
                    @index += match_len
                  else
                    terminal_parse_failure('"."')
                    r9 = nil
                  end
                  s0 << r9
                  if r9
                    s10, i10 = [], index
                    loop do
                      if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
                        r11 = true
                        @index += 1
                      else
                        terminal_parse_failure('[\\d]')
                        r11 = nil
                      end
                      if r11
                        s10 << r11
                      else
                        break
                      end
                    end
                    if s10.empty?
                      @index = i10
                      r10 = nil
                    else
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                    end
                    s0 << r10
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IpAddress0)
          r0.extend(IpAddress1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ip_address][start_index] = r0

        r0
      end

      module AaaaRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def ip_address
          elements[7]
        end
      end

      module AaaaRecord1
        def to_s
          "#{host} #{ttl} #{klass} AAAA #{ip_address}"
        end

        def record_type
          "AAAA"
        end
      end

      def _nt_aaaa_record
        start_index = index
        if node_cache[:aaaa_record].has_key?(index)
          cached = node_cache[:aaaa_record][index]
          if cached
            node_cache[:aaaa_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("AAAA", false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"AAAA"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_ip6_address
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AaaaRecord0)
          r0.extend(AaaaRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:aaaa_record][start_index] = r0

        r0
      end

      module Ip6Address0
        def to_s
          text_value.downcase
        end
      end

      def _nt_ip6_address
        start_index = index
        if node_cache[:ip6_address].has_key?(index)
          cached = node_cache[:ip6_address][index]
          if cached
            node_cache[:ip6_address][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\da-fA-F:.]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[\\da-fA-F:.]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
          if s0.size == 39
            break
          end
        end
        if s0.size < 2
          @index = i0
          r0 = nil
        else
          if s0.size < 39
            @terminal_failures.pop
          end
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ip6Address0)
          r0.extend(Ip6Address0)
        end

        node_cache[:ip6_address][start_index] = r0

        r0
      end

      module CnameRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def target
          elements[7]
        end
      end

      module CnameRecord1
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass
          elements[2]
        end

        def ms_age
          elements[3]
        end

        def ttl
          elements[4]
        end

        def space2
          elements[6]
        end

        def target
          elements[7]
        end
      end

      module CnameRecord2
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def space2
          elements[5]
        end

        def target
          elements[6]
        end
      end

      module CnameRecord3
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass
          elements[2]
        end

        def space2
          elements[4]
        end

        def target
          elements[5]
        end
      end

      module CnameRecord4
        def to_s
          "#{host} #{ttl} #{klass} CNAME #{target}"
        end

        def record_type
          "CNAME"
        end
      end

      def _nt_cname_record
        start_index = index
        if node_cache[:cname_record].has_key?(index)
          cached = node_cache[:cname_record][index]
          if cached
            node_cache[:cname_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_host
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
          if r3
            r4 = _nt_ms_age
            s1 << r4
            if r4
              r5 = _nt_ttl
              s1 << r5
              if r5
                r6 = _nt_klass
                s1 << r6
                if r6
                  if (match_len = has_terminal?("CNAME", false, index))
                    r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"CNAME"')
                    r7 = nil
                  end
                  s1 << r7
                  if r7
                    r8 = _nt_space
                    s1 << r8
                    if r8
                      r9 = _nt_host
                      s1 << r9
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CnameRecord0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(CnameRecord4)
          r0.extend(CnameRecord4)
        else
          i10, s10 = index, []
          r11 = _nt_host
          s10 << r11
          if r11
            r12 = _nt_space
            s10 << r12
            if r12
              r13 = _nt_klass
              s10 << r13
              if r13
                r14 = _nt_ms_age
                s10 << r14
                if r14
                  r15 = _nt_ttl
                  s10 << r15
                  if r15
                    if (match_len = has_terminal?("CNAME", false, index))
                      r16 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('"CNAME"')
                      r16 = nil
                    end
                    s10 << r16
                    if r16
                      r17 = _nt_space
                      s10 << r17
                      if r17
                        r18 = _nt_host
                        s10 << r18
                      end
                    end
                  end
                end
              end
            end
          end
          if s10.last
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            r10.extend(CnameRecord1)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
            r0 = r10
            r0.extend(CnameRecord4)
            r0.extend(CnameRecord4)
          else
            i19, s19 = index, []
            r20 = _nt_host
            s19 << r20
            if r20
              r21 = _nt_space
              s19 << r21
              if r21
                r22 = _nt_ms_age
                s19 << r22
                if r22
                  r23 = _nt_ttl
                  s19 << r23
                  if r23
                    if (match_len = has_terminal?("CNAME", false, index))
                      r24 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('"CNAME"')
                      r24 = nil
                    end
                    s19 << r24
                    if r24
                      r25 = _nt_space
                      s19 << r25
                      if r25
                        r26 = _nt_host
                        s19 << r26
                      end
                    end
                  end
                end
              end
            end
            if s19.last
              r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
              r19.extend(CnameRecord2)
            else
              @index = i19
              r19 = nil
            end
            if r19
              r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
              r0 = r19
              r0.extend(CnameRecord4)
              r0.extend(CnameRecord4)
            else
              i27, s27 = index, []
              r28 = _nt_host
              s27 << r28
              if r28
                r29 = _nt_space
                s27 << r29
                if r29
                  r30 = _nt_klass
                  s27 << r30
                  if r30
                    if (match_len = has_terminal?("CNAME", false, index))
                      r31 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('"CNAME"')
                      r31 = nil
                    end
                    s27 << r31
                    if r31
                      r32 = _nt_space
                      s27 << r32
                      if r32
                        r33 = _nt_host
                        s27 << r33
                      end
                    end
                  end
                end
              end
              if s27.last
                r27 = instantiate_node(SyntaxNode,input, i27...index, s27)
                r27.extend(CnameRecord3)
              else
                @index = i27
                r27 = nil
              end
              if r27
                r27 = SyntaxNode.new(input, (index-1)...index) if r27 == true
                r0 = r27
                r0.extend(CnameRecord4)
                r0.extend(CnameRecord4)
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:cname_record][start_index] = r0

        r0
      end

      module MxRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl
          elements[2]
        end

        def klass
          elements[3]
        end

        def space2
          elements[5]
        end

        def priority
          elements[6]
        end

        def space3
          elements[7]
        end

        def exchanger
          elements[8]
        end
      end

      module MxRecord1
        def to_s
          "#{host} #{ttl} #{klass} MX #{priority} #{exchanger}"
        end

        def record_type
          "MX"
        end
      end

      def _nt_mx_record
        start_index = index
        if node_cache[:mx_record].has_key?(index)
          cached = node_cache[:mx_record][index]
          if cached
            node_cache[:mx_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl
            s0 << r3
            if r3
              r4 = _nt_klass
              s0 << r4
              if r4
                if (match_len = has_terminal?("MX", false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('"MX"')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                  if r6
                    r7 = _nt_integer
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                      if r8
                        r9 = _nt_host
                        s0 << r9
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MxRecord0)
          r0.extend(MxRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:mx_record][start_index] = r0

        r0
      end

      module NaptrRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def data
          elements[7]
        end
      end

      module NaptrRecord1
        def to_s
          "#{host} #{ttl} #{klass} NAPTR #{data}"
        end

        def record_type
          "NAPTR"
        end
      end

      def _nt_naptr_record
        start_index = index
        if node_cache[:naptr_record].has_key?(index)
          cached = node_cache[:naptr_record][index]
          if cached
            node_cache[:naptr_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("NAPTR", false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"NAPTR"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_data
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NaptrRecord0)
          r0.extend(NaptrRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:naptr_record][start_index] = r0

        r0
      end

      module NsRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def nameserver
          elements[7]
        end
      end

      module NsRecord1
        def to_s
          "#{host} #{ttl} #{klass} NS #{nameserver}"
        end

        def record_type
          "NS"
        end
      end

      def _nt_ns_record
        start_index = index
        if node_cache[:ns_record].has_key?(index)
          cached = node_cache[:ns_record][index]
          if cached
            node_cache[:ns_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("NS", false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"NS"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_host
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NsRecord0)
          r0.extend(NsRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ns_record][start_index] = r0

        r0
      end

      module PtrRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def target
          elements[7]
        end
      end

      module PtrRecord1
        def to_s
          "#{host} #{ttl} #{klass} PTR #{target}"
        end

        def record_type
          "PTR"
        end
      end

      def _nt_ptr_record
        start_index = index
        if node_cache[:ptr_record].has_key?(index)
          cached = node_cache[:ptr_record][index]
          if cached
            node_cache[:ptr_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("PTR", false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"PTR"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_host
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PtrRecord0)
          r0.extend(PtrRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ptr_record][start_index] = r0

        r0
      end

      module SoaRecord0
        def origin
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def ns
          elements[7]
        end

        def space3
          elements[8]
        end

        def rp
          elements[9]
        end

        def space4
          elements[10]
        end

        def data
          elements[11]
        end
      end

      module SoaRecord1
        def to_s
          "#{origin} #{ttl} #{klass} SOA #{ns} #{rp} (#{space})"
        end

        def record_type
          "SOA"
        end
      end

      def _nt_soa_record
        start_index = index
        if node_cache[:soa_record].has_key?(index)
          cached = node_cache[:soa_record][index]
          if cached
            node_cache[:soa_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_origin
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("SOA", false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"SOA"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_ns
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                        if r9
                          r10 = _nt_rp
                          s0 << r10
                          if r10
                            r11 = _nt_space
                            s0 << r11
                            if r11
                              r12 = _nt_data
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SoaRecord0)
          r0.extend(SoaRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:soa_record][start_index] = r0

        r0
      end

      module SrvRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def priority
          elements[7]
        end

        def space3
          elements[8]
        end

        def weight
          elements[9]
        end

        def space4
          elements[10]
        end

        def port
          elements[11]
        end

        def space5
          elements[12]
        end

        def target
          elements[13]
        end
      end

      module SrvRecord1
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass
          elements[2]
        end

        def ms_age
          elements[3]
        end

        def ttl
          elements[4]
        end

        def space2
          elements[6]
        end

        def priority
          elements[7]
        end

        def space3
          elements[8]
        end

        def weight
          elements[9]
        end

        def space4
          elements[10]
        end

        def port
          elements[11]
        end

        def space5
          elements[12]
        end

        def target
          elements[13]
        end
      end

      module SrvRecord2
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def space2
          elements[5]
        end

        def priority
          elements[6]
        end

        def space3
          elements[7]
        end

        def weight
          elements[8]
        end

        def space4
          elements[9]
        end

        def port
          elements[10]
        end

        def space5
          elements[11]
        end

        def target
          elements[12]
        end
      end

      module SrvRecord3
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass
          elements[2]
        end

        def space2
          elements[4]
        end

        def priority
          elements[5]
        end

        def space3
          elements[6]
        end

        def weight
          elements[7]
        end

        def space4
          elements[8]
        end

        def port
          elements[9]
        end

        def space5
          elements[10]
        end

        def target
          elements[11]
        end
      end

      module SrvRecord4
        def to_s
          "#{host} #{ttl} #{klass} SRV #{priority} #{weight} #{port} #{target}"
        end

        def record_type
          "SRV"
        end
      end

      def _nt_srv_record
        start_index = index
        if node_cache[:srv_record].has_key?(index)
          cached = node_cache[:srv_record][index]
          if cached
            node_cache[:srv_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_host
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
          if r3
            r4 = _nt_ms_age
            s1 << r4
            if r4
              r5 = _nt_ttl
              s1 << r5
              if r5
                r6 = _nt_klass
                s1 << r6
                if r6
                  if (match_len = has_terminal?("SRV", false, index))
                    r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"SRV"')
                    r7 = nil
                  end
                  s1 << r7
                  if r7
                    r8 = _nt_space
                    s1 << r8
                    if r8
                      r9 = _nt_integer
                      s1 << r9
                      if r9
                        r10 = _nt_space
                        s1 << r10
                        if r10
                          r11 = _nt_integer
                          s1 << r11
                          if r11
                            r12 = _nt_space
                            s1 << r12
                            if r12
                              r13 = _nt_integer
                              s1 << r13
                              if r13
                                r14 = _nt_space
                                s1 << r14
                                if r14
                                  r15 = _nt_host
                                  s1 << r15
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(SrvRecord0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(SrvRecord4)
          r0.extend(SrvRecord4)
        else
          i16, s16 = index, []
          r17 = _nt_host
          s16 << r17
          if r17
            r18 = _nt_space
            s16 << r18
            if r18
              r19 = _nt_klass
              s16 << r19
              if r19
                r20 = _nt_ms_age
                s16 << r20
                if r20
                  r21 = _nt_ttl
                  s16 << r21
                  if r21
                    if (match_len = has_terminal?("SRV", false, index))
                      r22 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('"SRV"')
                      r22 = nil
                    end
                    s16 << r22
                    if r22
                      r23 = _nt_space
                      s16 << r23
                      if r23
                        r24 = _nt_integer
                        s16 << r24
                        if r24
                          r25 = _nt_space
                          s16 << r25
                          if r25
                            r26 = _nt_integer
                            s16 << r26
                            if r26
                              r27 = _nt_space
                              s16 << r27
                              if r27
                                r28 = _nt_integer
                                s16 << r28
                                if r28
                                  r29 = _nt_space
                                  s16 << r29
                                  if r29
                                    r30 = _nt_host
                                    s16 << r30
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if s16.last
            r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
            r16.extend(SrvRecord1)
          else
            @index = i16
            r16 = nil
          end
          if r16
            r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
            r0 = r16
            r0.extend(SrvRecord4)
            r0.extend(SrvRecord4)
          else
            i31, s31 = index, []
            r32 = _nt_host
            s31 << r32
            if r32
              r33 = _nt_space
              s31 << r33
              if r33
                r34 = _nt_ms_age
                s31 << r34
                if r34
                  r35 = _nt_ttl
                  s31 << r35
                  if r35
                    if (match_len = has_terminal?("SRV", false, index))
                      r36 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('"SRV"')
                      r36 = nil
                    end
                    s31 << r36
                    if r36
                      r37 = _nt_space
                      s31 << r37
                      if r37
                        r38 = _nt_integer
                        s31 << r38
                        if r38
                          r39 = _nt_space
                          s31 << r39
                          if r39
                            r40 = _nt_integer
                            s31 << r40
                            if r40
                              r41 = _nt_space
                              s31 << r41
                              if r41
                                r42 = _nt_integer
                                s31 << r42
                                if r42
                                  r43 = _nt_space
                                  s31 << r43
                                  if r43
                                    r44 = _nt_host
                                    s31 << r44
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
            if s31.last
              r31 = instantiate_node(SyntaxNode,input, i31...index, s31)
              r31.extend(SrvRecord2)
            else
              @index = i31
              r31 = nil
            end
            if r31
              r31 = SyntaxNode.new(input, (index-1)...index) if r31 == true
              r0 = r31
              r0.extend(SrvRecord4)
              r0.extend(SrvRecord4)
            else
              i45, s45 = index, []
              r46 = _nt_host
              s45 << r46
              if r46
                r47 = _nt_space
                s45 << r47
                if r47
                  r48 = _nt_klass
                  s45 << r48
                  if r48
                    if (match_len = has_terminal?("SRV", false, index))
                      r49 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('"SRV"')
                      r49 = nil
                    end
                    s45 << r49
                    if r49
                      r50 = _nt_space
                      s45 << r50
                      if r50
                        r51 = _nt_integer
                        s45 << r51
                        if r51
                          r52 = _nt_space
                          s45 << r52
                          if r52
                            r53 = _nt_integer
                            s45 << r53
                            if r53
                              r54 = _nt_space
                              s45 << r54
                              if r54
                                r55 = _nt_integer
                                s45 << r55
                                if r55
                                  r56 = _nt_space
                                  s45 << r56
                                  if r56
                                    r57 = _nt_host
                                    s45 << r57
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
              if s45.last
                r45 = instantiate_node(SyntaxNode,input, i45...index, s45)
                r45.extend(SrvRecord3)
              else
                @index = i45
                r45 = nil
              end
              if r45
                r45 = SyntaxNode.new(input, (index-1)...index) if r45 == true
                r0 = r45
                r0.extend(SrvRecord4)
                r0.extend(SrvRecord4)
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:srv_record][start_index] = r0

        r0
      end

      module SpfRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def data
          elements[7]
        end
      end

      module SpfRecord1
        def to_s
          "#{host} #{ttl} #{klass} SPF #{data}"
        end

        def record_type
          "SPF"
        end
      end

      def _nt_spf_record
        start_index = index
        if node_cache[:spf_record].has_key?(index)
          cached = node_cache[:spf_record][index]
          if cached
            node_cache[:spf_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("SPF", false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"SPF"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_txt_data
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SpfRecord0)
          r0.extend(SpfRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:spf_record][start_index] = r0

        r0
      end

      module TxtRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ms_age
          elements[2]
        end

        def ttl
          elements[3]
        end

        def klass
          elements[4]
        end

        def space2
          elements[6]
        end

        def data
          elements[7]
        end
      end

      module TxtRecord1
        def to_s
          "#{host} #{ttl} #{klass} TXT #{data}"
        end

        def record_type
          "TXT"
        end
      end

      def _nt_txt_record
        start_index = index
        if node_cache[:txt_record].has_key?(index)
          cached = node_cache[:txt_record][index]
          if cached
            node_cache[:txt_record][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ms_age
            s0 << r3
            if r3
              r4 = _nt_ttl
              s0 << r4
              if r4
                r5 = _nt_klass
                s0 << r5
                if r5
                  if (match_len = has_terminal?("TXT", false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('"TXT"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_ms_txt_data
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TxtRecord0)
          r0.extend(TxtRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:txt_record][start_index] = r0

        r0
      end

      module Origin0
        def host
          elements[0]
        end

      end

      module Origin1
        def to_s
          "#{host}"
        end
      end

      def _nt_origin
        start_index = index
        if node_cache[:origin].has_key?(index)
          cached = node_cache[:origin][index]
          if cached
            node_cache[:origin][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Origin0)
          r0.extend(Origin1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:origin][start_index] = r0

        r0
      end

      module MultilineComment0
      end

      module MultilineComment1
        def to_s
          text_value.strip
        end
      end

      def _nt_multiline_comment
        start_index = index
        if node_cache[:multiline_comment].has_key?(index)
          cached = node_cache[:multiline_comment][index]
          if cached
            node_cache[:multiline_comment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          r2 = _nt_linebreak
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          s3, i3 = [], index
          loop do
            r4 = _nt_comment
            if r4
              s3 << r4
            else
              break
            end
          end
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MultilineComment0)
          r0.extend(MultilineComment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:multiline_comment][start_index] = r0

        r0
      end

      module Space0
        def to_s
          text_value
        end
      end

      def _nt_space
        start_index = index
        if node_cache[:space].has_key?(index)
          cached = node_cache[:space][index]
          if cached
            node_cache[:space][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[ \\t]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[ \\t]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Space0)
          r0.extend(Space0)
        end

        node_cache[:space][start_index] = r0

        r0
      end

      module Linebreak0
        def to_s
          ''
        end
      end

      def _nt_linebreak
        start_index = index
        if node_cache[:linebreak].has_key?(index)
          cached = node_cache[:linebreak][index]
          if cached
            node_cache[:linebreak][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\n\\r]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[\\n\\r]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Linebreak0)
          r0.extend(Linebreak0)
        end

        node_cache[:linebreak][start_index] = r0

        r0
      end

      module SpaceOrBreak0
        def to_s
          text_value
        end
      end

      def _nt_space_or_break
        start_index = index
        if node_cache[:space_or_break].has_key?(index)
          cached = node_cache[:space_or_break][index]
          if cached
            node_cache[:space_or_break][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\s]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[\\s]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SpaceOrBreak0)
          r0.extend(SpaceOrBreak0)
        end

        node_cache[:space_or_break][start_index] = r0

        r0
      end

      module Klass0
        def space
          elements[1]
        end
      end

      module Klass1
        def to_s
          text_value.strip
        end
      end

      def _nt_klass
        start_index = index
        if node_cache[:klass].has_key?(index)
          cached = node_cache[:klass][index]
          if cached
            node_cache[:klass][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?("IN", false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"IN"')
          r2 = nil
        end
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Klass0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(Klass1)
          r0.extend(Klass1)
        else
          if (match_len = has_terminal?('', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('\'\'')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
            r0.extend(Klass1)
            r0.extend(Klass1)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:klass][start_index] = r0

        r0
      end

      module Comment0
      end

      module Comment1
        def to_s
          text_value.strip
        end
      end

      def _nt_comment
        start_index = index
        if node_cache[:comment].has_key?(index)
          cached = node_cache[:comment][index]
          if cached
            node_cache[:comment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          r2 = _nt_space
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          if (match_len = has_terminal?(";", false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('";"')
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[^\\n\\r]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[^\\n\\r]')
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Comment0)
          r0.extend(Comment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:comment][start_index] = r0

        r0
      end

      module Ns0
        def host
          elements[0]
        end

      end

      module Ns1
        def to_s
          "#{host}"
        end
      end

      def _nt_ns
        start_index = index
        if node_cache[:ns].has_key?(index)
          cached = node_cache[:ns][index]
          if cached
            node_cache[:ns][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ns0)
          r0.extend(Ns1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ns][start_index] = r0

        r0
      end

      module Rp0
      end

      module Rp1
        def to_s
          text_value
        end
      end

      def _nt_rp
        start_index = index
        if node_cache[:rp].has_key?(index)
          cached = node_cache[:rp][index]
          if cached
            node_cache[:rp][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1, s1 = index, []
          s2, i2 = [], index
          loop do
            i3 = index
            if (match_len = has_terminal?("\\.", false, index))
              r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('"\\\\."')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              if has_terminal?(@regexps[gr = '\A[+a-zA-Z0-9\\-)]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[+a-zA-Z0-9\\-)]')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s1 << r2
          if r2
            if (match_len = has_terminal?(".", false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('"."')
              r6 = nil
            end
            s1 << r6
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(Rp0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Rp1)
          r0.extend(Rp1)
        end

        node_cache[:rp][start_index] = r0

        r0
      end

      module Serial0
        def integer
          elements[0]
        end

      end

      module Serial1
        def to_i
          integer.to_i
        end
        def to_s
          "#{to_i}"
        end
      end

      def _nt_serial
        start_index = index
        if node_cache[:serial].has_key?(index)
          cached = node_cache[:serial][index]
          if cached
            node_cache[:serial][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Serial0)
          r0.extend(Serial1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:serial][start_index] = r0

        r0
      end

      module TimeInterval0
        def integer
          elements[0]
        end

        def time_multiplier
          elements[1]
        end
      end

      module TimeInterval1
        def to_s
          text_value
        end

        def to_i
          time_multiplier.to_i * integer.to_i
        end
      end

      def _nt_time_interval
        start_index = index
        if node_cache[:time_interval].has_key?(index)
          cached = node_cache[:time_interval][index]
          if cached
            node_cache[:time_interval][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer
        s0 << r1
        if r1
          r2 = _nt_time_multiplier
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TimeInterval0)
          r0.extend(TimeInterval1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:time_interval][start_index] = r0

        r0
      end

      module Refresh0
        def time_interval
          elements[0]
        end

      end

      module Refresh1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_refresh
        start_index = index
        if node_cache[:refresh].has_key?(index)
          cached = node_cache[:refresh][index]
          if cached
            node_cache[:refresh][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Refresh0)
          r0.extend(Refresh1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:refresh][start_index] = r0

        r0
      end

      module Integer0
        def to_i
          text_value.to_i
        end
        def to_s
          "#{to_i}"
        end
      end

      def _nt_integer
        start_index = index
        if node_cache[:integer].has_key?(index)
          cached = node_cache[:integer][index]
          if cached
            node_cache[:integer][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Integer0)
          r0.extend(Integer0)
        end

        node_cache[:integer][start_index] = r0

        r0
      end

      module TimeMultiplier0
        def to_s
          text_value
        end
        def to_i
          case text_value.downcase
            when 'm' then 60
            when 'h' then 60 * 60
            when 'd' then 60 * 60 * 24
            when 'w' then 60 * 60 * 24 * 7
            else
              1
          end
        end
      end

      def _nt_time_multiplier
        start_index = index
        if node_cache[:time_multiplier].has_key?(index)
          cached = node_cache[:time_multiplier][index]
          if cached
            node_cache[:time_multiplier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('s', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'s\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(TimeMultiplier0)
          r0.extend(TimeMultiplier0)
        else
          if (match_len = has_terminal?('S', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('\'S\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
            r0.extend(TimeMultiplier0)
            r0.extend(TimeMultiplier0)
          else
            if (match_len = has_terminal?('m', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'m\'')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
              r0.extend(TimeMultiplier0)
              r0.extend(TimeMultiplier0)
            else
              if (match_len = has_terminal?('M', false, index))
                r4 = true
                @index += match_len
              else
                terminal_parse_failure('\'M\'')
                r4 = nil
              end
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
                r0.extend(TimeMultiplier0)
                r0.extend(TimeMultiplier0)
              else
                if (match_len = has_terminal?('h', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'h\'')
                  r5 = nil
                end
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                  r0.extend(TimeMultiplier0)
                  r0.extend(TimeMultiplier0)
                else
                  if (match_len = has_terminal?('H', false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'H\'')
                    r6 = nil
                  end
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                    r0.extend(TimeMultiplier0)
                    r0.extend(TimeMultiplier0)
                  else
                    if (match_len = has_terminal?('d', false, index))
                      r7 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\'d\'')
                      r7 = nil
                    end
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                      r0.extend(TimeMultiplier0)
                      r0.extend(TimeMultiplier0)
                    else
                      if (match_len = has_terminal?('D', false, index))
                        r8 = true
                        @index += match_len
                      else
                        terminal_parse_failure('\'D\'')
                        r8 = nil
                      end
                      if r8
                        r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                        r0 = r8
                        r0.extend(TimeMultiplier0)
                        r0.extend(TimeMultiplier0)
                      else
                        if (match_len = has_terminal?('w', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'w\'')
                          r9 = nil
                        end
                        if r9
                          r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                          r0 = r9
                          r0.extend(TimeMultiplier0)
                          r0.extend(TimeMultiplier0)
                        else
                          if (match_len = has_terminal?('W', false, index))
                            r10 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\'W\'')
                            r10 = nil
                          end
                          if r10
                            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                            r0 = r10
                            r0.extend(TimeMultiplier0)
                            r0.extend(TimeMultiplier0)
                          else
                            if (match_len = has_terminal?('', false, index))
                              r11 = true
                              @index += match_len
                            else
                              terminal_parse_failure('\'\'')
                              r11 = nil
                            end
                            if r11
                              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                              r0 = r11
                              r0.extend(TimeMultiplier0)
                              r0.extend(TimeMultiplier0)
                            else
                              @index = i0
                              r0 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:time_multiplier][start_index] = r0

        r0
      end

      module Reretry0
        def time_interval
          elements[0]
        end

      end

      module Reretry1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_reretry
        start_index = index
        if node_cache[:reretry].has_key?(index)
          cached = node_cache[:reretry][index]
          if cached
            node_cache[:reretry][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Reretry0)
          r0.extend(Reretry1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:reretry][start_index] = r0

        r0
      end

      module Expiry0
        def time_interval
          elements[0]
        end

      end

      module Expiry1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_expiry
        start_index = index
        if node_cache[:expiry].has_key?(index)
          cached = node_cache[:expiry][index]
          if cached
            node_cache[:expiry][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Expiry0)
          r0.extend(Expiry1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:expiry][start_index] = r0

        r0
      end

      module Nxttl0
        def time_interval
          elements[0]
        end

      end

      module Nxttl1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_nxttl
        start_index = index
        if node_cache[:nxttl].has_key?(index)
          cached = node_cache[:nxttl][index]
          if cached
            node_cache[:nxttl][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Nxttl0)
          r0.extend(Nxttl1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:nxttl][start_index] = r0

        r0
      end

      module MsAge0
        def space
          elements[3]
        end
      end

      module MsAge1
        def to_s
          text_value
        end
      end

      def _nt_ms_age
        start_index = index
        if node_cache[:ms_age].has_key?(index)
          cached = node_cache[:ms_age][index]
          if cached
            node_cache[:ms_age][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?("[AGE:", false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('"[AGE:"')
          r2 = nil
        end
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[\\d]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[\\d]')
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
          if r3
            if (match_len = has_terminal?("]", false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('"]"')
              r5 = nil
            end
            s1 << r5
            if r5
              r6 = _nt_space
              s1 << r6
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(MsAge0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(MsAge1)
          r0.extend(MsAge1)
        else
          if (match_len = has_terminal?('', false, index))
            r7 = true
            @index += match_len
          else
            terminal_parse_failure('\'\'')
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
            r0.extend(MsAge1)
            r0.extend(MsAge1)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:ms_age][start_index] = r0

        r0
      end

      module Ttl0
        def time_interval
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module Ttl1
        def to_i
          respond_to?(:time_interval) ? time_interval.to_i : nil
        end
        def to_s
          respond_to?(:time_interval) ? time_interval.to_s : ''
        end
      end

      def _nt_ttl
        start_index = index
        if node_cache[:ttl].has_key?(index)
          cached = node_cache[:ttl][index]
          if cached
            node_cache[:ttl][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_time_interval
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Ttl0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(Ttl1)
          r0.extend(Ttl1)
        else
          if (match_len = has_terminal?('', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('\'\'')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
            r0.extend(Ttl1)
            r0.extend(Ttl1)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:ttl][start_index] = r0

        r0
      end

      module Host0
        def to_s
          case text_value
          when /\.$/
            text_value
          when "@", /\s/
            text_value
          else
            text_value + '.@'
          end
        end
      end

      def _nt_host
        start_index = index
        if node_cache[:host].has_key?(index)
          cached = node_cache[:host][index]
          if cached
            node_cache[:host][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        s1, i1 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[*a-zA-Z0-9\\-\\._]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[*a-zA-Z0-9\\-\\._]')
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(Host0)
          r0.extend(Host0)
        else
          if (match_len = has_terminal?("@", false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('"@"')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r0 = r3
            r0.extend(Host0)
            r0.extend(Host0)
          else
            if (match_len = has_terminal?(' ', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\' \'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r0 = r4
              r0.extend(Host0)
              r0.extend(Host0)
            else
              if (match_len = has_terminal?("\t", false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('"\\t"')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r0 = r5
                r0.extend(Host0)
                r0.extend(Host0)
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:host][start_index] = r0

        r0
      end

      module Data0
        def to_s
          text_value.strip
        end
      end

      def _nt_data
        start_index = index
        if node_cache[:data].has_key?(index)
          cached = node_cache[:data][index]
          if cached
            node_cache[:data][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[^;\\n\\r]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[^;\\n\\r]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Data0)
          r0.extend(Data0)
        end

        node_cache[:data][start_index] = r0

        r0
      end

      module MsTxtData0
        def data
          elements[2]
        end

      end

      module MsTxtData1
        def data
          elements[0]
        end
      end

      module MsTxtData2
        def to_s
          data.to_s
        end
      end

      def _nt_ms_txt_data
        start_index = index
        if node_cache[:ms_txt_data].has_key?(index)
          cached = node_cache[:ms_txt_data][index]
          if cached
            node_cache[:ms_txt_data][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?("(", false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('"("')
          r2 = nil
        end
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            r4 = _nt_space
            if r4
              s3 << r4
            else
              break
            end
          end
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          s1 << r3
          if r3
            r5 = _nt_txt_data
            s1 << r5
            if r5
              s6, i6 = [], index
              loop do
                r7 = _nt_space
                if r7
                  s6 << r7
                else
                  break
                end
              end
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              s1 << r6
              if r6
                if (match_len = has_terminal?(")", false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('")"')
                  r8 = nil
                end
                s1 << r8
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(MsTxtData0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(MsTxtData2)
          r0.extend(MsTxtData2)
        else
          i9, s9 = index, []
          r10 = _nt_txt_data
          s9 << r10
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(MsTxtData1)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
            r0.extend(MsTxtData2)
            r0.extend(MsTxtData2)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:ms_txt_data][start_index] = r0

        r0
      end

      module TxtData0
        def space
          elements[0]
        end

        def txt_data
          elements[1]
        end
      end

      module TxtData1
        def txt_string
          elements[0]
        end

      end

      module TxtData2
        def to_s
          text_value
        end
      end

      def _nt_txt_data
        start_index = index
        if node_cache[:txt_data].has_key?(index)
          cached = node_cache[:txt_data][index]
          if cached
            node_cache[:txt_data][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_txt_string
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_space
            s3 << r4
            if r4
              r5 = _nt_txt_data
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(TxtData0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TxtData1)
          r0.extend(TxtData2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:txt_data][start_index] = r0

        r0
      end

      module TxtString0
        def to_s
          text_value
        end
      end

      def _nt_txt_string
        start_index = index
        if node_cache[:txt_string].has_key?(index)
          cached = node_cache[:txt_string][index]
          if cached
            node_cache[:txt_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_quoted_string
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(TxtString0)
          r0.extend(TxtString0)
        else
          r2 = _nt_unquoted_string
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
            r0.extend(TxtString0)
            r0.extend(TxtString0)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:txt_string][start_index] = r0

        r0
      end

      module QuotedString0
      end

      module QuotedString1
        def to_s
          text_value
        end
      end

      def _nt_quoted_string
        start_index = index
        if node_cache[:quoted_string].has_key?(index)
          cached = node_cache[:quoted_string][index]
          if cached
            node_cache[:quoted_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('"', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'"\'')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3 = index
            if (match_len = has_terminal?('\"', false, index))
              r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'\\"\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              if has_terminal?(@regexps[gr = '\A[^"]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[^"]')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?('"', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('\'"\'')
              r6 = nil
            end
            s0 << r6
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(QuotedString0)
          r0.extend(QuotedString1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:quoted_string][start_index] = r0

        r0
      end

      module UnquotedString0
        def to_s
          text_value
        end
      end

      def _nt_unquoted_string
        start_index = index
        if node_cache[:unquoted_string].has_key?(index)
          cached = node_cache[:unquoted_string][index]
          if cached
            node_cache[:unquoted_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[a-zA-Z0-9]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UnquotedString0)
          r0.extend(UnquotedString0)
        end

        node_cache[:unquoted_string][start_index] = r0

        r0
      end

    end

    class Parser < Treetop::Runtime::CompiledParser
      include ZonefileGrammar # :nodoc:
    end
  end
end